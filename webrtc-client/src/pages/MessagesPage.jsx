/*
 * BACKEND REQUIREMENTS FOR REAL-TIME CONVERSATION UPDATES:
 * 
 * ⚠️  CRITICAL: ALL SYSTEM MESSAGES MUST BE GENERATED BY THE BACKEND
 * The client should NEVER manually send system messages - they must come from the server.
 * 
 * When POST /conversations is called (conversation creation):
 *   1. Create the conversation in database
 *   2. Emit to all members: 'conversation:created' 
 *      Payload: { ...conversationObject, members: [...], createdBy: userId }
 *   3. ⭐ AUTOMATICALLY create a system message in the database:
 *      INSERT INTO messages {
 *        conversationId: newConversation._id,
 *        text: "🎉 [conversationName] was created!",
 *        type: "system",
 *        isSystemMessage: true,
 *        senderId: "system",
 *        createdAt: new Date()
 *      }
 *   4. Emit the system message via socket: 'chat:new' with the system message
 * 
 * When POST /conversations/:id/members is called (member addition):
 *   1. Add member to conversation
 *   2. Emit to all members: 'conversation:memberAdded'
 *   3. ⭐ AUTOMATICALLY create and emit system message:
 *      { text: "👋 [memberName] was added to the group", type: "system", 
 *        isSystemMessage: true, senderId: "system" }
 * 
 * When DELETE /conversations/:id is called (conversation deletion):
 *   1. For deleter: Emit 'conversation:deleted' with immediate removal
 *   2. For others: Create system message about deletion and emit via 'chat:new'
 * 
 * ✅ This ensures system messages appear as small centered notifications,
 *    not as regular user messages, and are properly stored in the database.
 */

import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { User, Users, Hash, Plus, Search, MoreVertical, Settings, Star, Trash2, Send, Paperclip, Smile, MessageCircle, X, Check } from 'lucide-react';
import SidebarConversation from '../components/messages/SidebarConversation';
import ChatWindow from '../components/messages/ChatWindow';
import ChatInput from '../components/messages/ChatInput';
import ChatSearch from '../components/messages/ChatSearch';
import CreateConversationModal from '../components/messages/CreateConversationModal';
import UserSelectionModal from '../components/messages/UserSelectionModal';
import ConversationSettingsModal from '../components/messages/ConversationSettingsModal';
import ConversationDetailsModal from '../components/messages/ConversationDetailsModal';
import * as conversationAPI from '../api/conversationService';
import * as messageAPI from '../api/messageService';
import { useAuth } from '../context/AuthContext';
import { useChatSocket } from '../context/ChatSocketContext';
import { useAvatarConversation } from '../hooks/useAvatarConversation';
import AvatarService from '../services/avatarService';
import BotService from '../api/botService';
import { useCurrentConversation } from '../context/CurrentConversationContext';
import { useNotifications } from '../context/NotificationContext';
import { useMediaQuery } from 'react-responsive';
import { useMessageNotifications } from '../components/Layout';
import NetworkStatus from '../components/NetworkStatus';
import { messageQueue } from '../services/messageQueue';
import { messageStatus, MESSAGE_STATUS } from '../services/messageStatus';


// Placeholder for emoji list
const emojiList = ['👍', '❤️', '😂', '😮', '😢', '😡', '👏', '🙏', '🔥', '💯', '✨', '🎉', '🤔', '😎', '🥳', '😴'];

function getInitials(name) {
  if (!name || typeof name !== 'string') {
    return 'U';
  }
  
  const result = name.split(' ').map(n => n[0]).join('').toUpperCase();
  return result;
}

function getConversationDisplayName(conversation, currentUserId) {
  try {
    if (!conversation) {
      return 'Unknown';
    }
    
    // If conversation has a name (group/community), use it
    if (conversation.name) {
      return String(conversation.name);
    }
    
    // For DMs, show the other person's name
    if (conversation.type === 'dm' && Array.isArray(conversation.members)) {
      const otherMember = conversation.members.find(m => m._id !== currentUserId);
      
      if (otherMember && typeof otherMember === 'object') {
        // Ensure we're working with a user object and extract string values
        const fullName = otherMember.fullName;
        const username = otherMember.username;
        const email = otherMember.email;
        
        const displayName = fullName || username || email || 'Unknown User';
        
        // Ensure we return a string
        return String(displayName);
      } else {
        return 'Unknown User';
      }
    }
    
    // Fallback
    return 'Unknown Conversation';
  } catch (error) {
    console.error('Error in MessagesPage getConversationDisplayName:', error);
    return 'Error';
  }
}

function groupMessagesByDate(messages) {
  return messages.reduce((acc, msg) => {
    const date = new Date(msg.createdAt || msg.timestamp || Date.now()).toLocaleDateString();
    if (!acc[date]) acc[date] = [];
    acc[date].push(msg);
    return acc;
  }, {});
}

export default function MessagesPage() {
  const { user } = useAuth();
  const chatSocket = useChatSocket();
  const { updateCurrentConversation, updateMessagesPageStatus, clearCurrentConversation } = useCurrentConversation();
  const { clearNotificationsForConversation } = useNotifications();
  const { avatarConversation, isAvatarConversation, processAvatarQuery, isInitialized, isLoading } = useAvatarConversation();
  
  // Debug avatar conversation state
  useEffect(() => {
    console.log('🤖 MessagesPage: Avatar conversation state changed:', {
      avatarConversation: avatarConversation ? { id: avatarConversation._id, name: avatarConversation.name } : null,
      user: user ? { id: user._id, name: user.fullName || user.username } : null
    });
  }, [avatarConversation, user]);
  const [allConversations, setAllConversations] = useState([]);
  const [selected, setSelected] = useState(null);
  const [forceUpdate, setForceUpdate] = useState(0); // Force re-render when needed
  const [messages, setMessages] = useState([]);
  const [pendingConversationId, setPendingConversationId] = useState(null);
  // Track whether messages are currently being fetched. When true, the chat
  // window will display a loading spinner. Messages remain an array to avoid
  // errors in event handlers that spread or map over the messages array.
  const [messagesLoading, setMessagesLoading] = useState(false);
  const [isConversationSwitch, setIsConversationSwitch] = useState(false);
  const [input, setInput] = useState('');
  const [search, setSearch] = useState('');
  const [showUserModal, setShowUserModal] = useState(false);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showSettingsModal, setShowSettingsModal] = useState(false);
  const [showDetailsModal, setShowDetailsModal] = useState(false);
  const [starred, setStarred] = useState([]);
  const [typing, setTyping] = useState({});
  const [editMsgId, setEditMsgId] = useState(null);
  const [editInput, setEditInput] = useState('');
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [uploadFile, setUploadFile] = useState(null);
  const [reactions, setReactions] = useState({});
  const [replyTo, setReplyTo] = useState(null);
  const [notification, setNotification] = useState(null);
  
  // Track where unread messages start (for unread indicator)
  const [unreadStartIndex, setUnreadStartIndex] = useState(null);
  const [lastReadMessageId, setLastReadMessageId] = useState(null);
  
  // Track conversations already marked as read to prevent duplicate API calls
  const readConversationsRef = useRef(new Set());
  const markReadTimeoutRef = useRef(null);
  
  // Initialize messages cache with localStorage persistence
  const [messagesCache, setMessagesCache] = useState(() => {
    try {
      const cached = localStorage.getItem('messagesCache');
      return cached ? JSON.parse(cached) : {};
    } catch (error) {
      console.warn('Failed to load messages cache from localStorage:', error);
      return {};
    }
  });
  const [isSending, setIsSending] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const { refreshUnreadCount } = useMessageNotifications();
  const windowFocused = useRef(true);
  const selectedRef = useRef(selected);
  const messagesCacheRef = useRef(messagesCache);
  const allConversationsRef = useRef(allConversations);
  const isMobile = useMediaQuery({ maxWidth: 767 });

  // Enhanced merge function with better deduplication
  const mergeMessages = (serverMessages, cachedMessages) => {
    const messageMap = new Map();
    const tempIdMap = new Map(); // Track tempId to _id mapping
    
    // First pass: Add all server messages (source of truth)
    serverMessages.forEach(msg => {
      if (msg._id) {
        messageMap.set(msg._id, msg);
        // Track tempId mapping if present
        if (msg.tempId) {
          tempIdMap.set(msg.tempId, msg._id);
        }
      }
    });
    
    // Second pass: Add cached messages that aren't duplicates
    cachedMessages.forEach(msg => {
      // Skip if this is a server message we already have
      if (msg._id && messageMap.has(msg._id)) {
        return;
      }
      
      // Skip if this temp message has a corresponding server message by tempId
      if (msg.tempId && tempIdMap.has(msg.tempId)) {
        return;
      }
      
      // CRITICAL: Skip temp messages that have server equivalents by content matching
      // This handles cases where server message doesn't include tempId
      if ((msg._id?.startsWith('temp-') || msg.tempId || msg.pending || msg.sending) && msg.senderId) {
        const hasServerEquivalent = serverMessages.some(serverMsg => {
          // Must be from same sender - handle both senderId and sender fields
          const serverSenderId = serverMsg.senderId || (typeof serverMsg.sender === 'object' ? serverMsg.sender?._id : serverMsg.sender);
          if (serverSenderId !== msg.senderId) return false;
          
          // Must have identical text content (including null/undefined handling)
          const serverText = serverMsg.text || '';
          const msgText = msg.text || '';
          if (serverText !== msgText) return false;
          
          // Flexible timestamp comparison - try multiple timestamp fields
          const serverTime = new Date(serverMsg.createdAt || serverMsg.timestamp || 0);
          const msgTime = new Date(msg.createdAt || msg.timestamp || msg.sentAt || 0);
          const timeDiff = Math.abs(serverTime - msgTime);
          
          // Extended time window to 10 minutes to handle edge cases
          return timeDiff < 600000; // 10 minutes
        });
        
        if (hasServerEquivalent) {
          return;
        }
      }
      
      // Add temporary/optimistic messages that don't have server equivalents
      if (msg.tempId || (msg._id && msg._id.startsWith('temp-'))) {
        const key = msg._id || msg.tempId || `temp-${Date.now()}`;
        if (!messageMap.has(key)) {
          messageMap.set(key, msg);
        }
      } else if (msg._id) {
        // Add real messages that aren't in server response (newer real-time messages)
        messageMap.set(msg._id, msg);
      }
    });
    
    // Convert back to array and sort by timestamp
    const merged = Array.from(messageMap.values())
      .filter(msg => msg && (msg._id || msg.tempId)) // Filter out invalid messages
      .sort((a, b) => {
        const dateA = new Date(a.createdAt || a.timestamp || 0);
        const dateB = new Date(b.createdAt || b.timestamp || 0);
        return dateA - dateB;
      });
    
    // Final aggressive cleanup: Remove temp messages that have real server equivalents
    // This is a failsafe in case the earlier content matching missed something
    const finalCleaned = merged.filter((msg, index) => {
      // Only check temp messages
      if (!(msg._id?.startsWith('temp-') || msg.tempId || msg.pending || msg.sending)) {
        return true; // Keep non-temp messages
      }
      
      // Check if any later message in the array is a server equivalent
      const hasLaterServerEquivalent = merged.slice(index + 1).some(laterMsg => {
        // Must not be a temp message itself
        if (laterMsg._id?.startsWith('temp-') || laterMsg.tempId || laterMsg.pending || laterMsg.sending) {
          return false;
        }
        
        // Same sender and text check
        return laterMsg.senderId === msg.senderId && 
               (laterMsg.text || '') === (msg.text || '') &&
               Math.abs(new Date(laterMsg.createdAt || 0) - new Date(msg.createdAt || msg.timestamp || 0)) < 600000; // 10 minutes
      });
      
      if (hasLaterServerEquivalent) {
        return false;
      }
      
      return true;
    });
    
    return finalCleaned;
  };
  const [sidebarOpen, setSidebarOpen] = useState(true); // for mobile
  
  // Avatar conversation messages storage (client-side with localStorage persistence)
  const [avatarMessages, setAvatarMessages] = useState(() => {
    try {
      const saved = localStorage.getItem('avatarMessages');
      if (saved) {
        const parsed = JSON.parse(saved);
        // Convert object back to Map
        return new Map(Object.entries(parsed));
      }
    } catch (error) {
      console.error('Error loading avatar messages from localStorage:', error);
    }
    return new Map();
  });
  
  // Debouncing ref to prevent excessive fetchConversations calls
  const fetchDebounceRef = useRef(null);
  const lastFetchTimeRef = useRef(0);

  // Pinned conversations state with localStorage persistence (moved here to fix hoisting issue)
  const [pinnedConversations, setPinnedConversations] = useState(() => {
    try {
      const saved = localStorage.getItem('pinnedConversations');
      return saved ? JSON.parse(saved) : [];
    } catch (error) {
      console.error('Error loading pinned conversations from localStorage:', error);
      return [];
    }
  });

  // Enhanced helper function to sort conversations with hierarchy: Avatar → Pinned → Regular
  const sortConversationsWithAvatarTop = (conversations) => {
    return conversations.sort((a, b) => {
      // Check if either conversation is an avatar conversation (multiple ways to detect)
      const aIsAvatar = a.conversationType === 'ai_avatar' || 
                       a.settings?.isAvatarConversation || 
                       a._id?.startsWith('avatar_conversation_');
      const bIsAvatar = b.conversationType === 'ai_avatar' || 
                       b.settings?.isAvatarConversation || 
                       b._id?.startsWith('avatar_conversation_');
      
      // Avatar conversations always go to the top (highest priority)
      if (aIsAvatar && !bIsAvatar) return -1;
      if (!aIsAvatar && bIsAvatar) return 1;
      
      // If both are avatar conversations, sort by creation (but this is unlikely)
      if (aIsAvatar && bIsAvatar) return 0;
      
      // For non-avatar conversations, handle pinned status (second priority)
      const aIsPinned = a.isPinned === true;
      const bIsPinned = b.isPinned === true;
      
      // Pinned conversations come before unpinned ones
      if (aIsPinned && !bIsPinned) return -1;
      if (!aIsPinned && bIsPinned) return 1;
      
      // Within same group (both pinned or both unpinned), sort by last message date
      const dateA = new Date(a.lastMessageAt || a.createdAt);
      const dateB = new Date(b.lastMessageAt || b.createdAt);
      return dateB - dateA;
    });
  };

  // Define fetchConversations function early to avoid hoisting issues  
  const fetchConversations = useCallback(async (forceRefresh = false) => {
    try {
      // Debounce rapid calls - only allow one call per 2 seconds unless forced
      const now = Date.now();
      if (!forceRefresh && (now - lastFetchTimeRef.current) < 2000) {
        return;
      }
      
      lastFetchTimeRef.current = now;
      
      const res = await conversationAPI.getConversations();
      const conversations = res.data.conversations || res.data || [];
      
      // Sort conversations by lastMessageAt within each type, but keep avatar conversations at top
      const sortByLastMessage = (a, b) => {
        // Check if either conversation is an avatar conversation
        const aIsAvatar = a.conversationType === 'ai_avatar' || a.settings?.isAvatarConversation;
        const bIsAvatar = b.conversationType === 'ai_avatar' || b.settings?.isAvatarConversation;
        
        // Avatar conversations always go to the top
        if (aIsAvatar && !bIsAvatar) return -1;
        if (!aIsAvatar && bIsAvatar) return 1;
        
        // If both are avatar conversations, sort by creation (but this is unlikely)
        if (aIsAvatar && bIsAvatar) return 0;
        
        // Normal sorting by last message date for non-avatar conversations
        const dateA = new Date(a.lastMessageAt || a.createdAt);
        const dateB = new Date(b.lastMessageAt || b.createdAt);
        return dateB - dateA;
      };
      
      // Remove duplicates from API data
      const deduplicateConversations = (conversations) => {
        const idMap = new Map();
        const nameMap = new Map();
        
        return conversations.filter((conv) => {
          // Remove ID duplicates
          if (idMap.has(conv._id)) {
            return false;
          }
          idMap.set(conv._id, true);
          
          // Remove name duplicates for communities
          if (conv.type === 'community' && conv.name) {
            if (nameMap.has(conv.name)) {
              return false;
            }
            nameMap.set(conv.name, true);
          }
          
          return true;
        });
      };
      
      const dmConversations = deduplicateConversations(conversations.filter(c => c.type === 'dm')).sort(sortByLastMessage);
      const groupConversations = deduplicateConversations(conversations.filter(c => c.type === 'group')).sort(sortByLastMessage);
      const communityConversations = deduplicateConversations(conversations.filter(c => c.type === 'community')).sort(sortByLastMessage);
      
      // Combine all conversations into a single unified list, restore pinned state, then sort
      let allConversationsUnified = [...dmConversations, ...groupConversations, ...communityConversations].map(conv => ({
        ...conv,
        isPinned: pinnedConversations.includes(conv._id)
      }));
      
      // Sort with hierarchy: Avatar → Pinned → Regular
      allConversationsUnified = sortConversationsWithAvatarTop(allConversationsUnified);
      
      // Add avatar conversation at the top - ALWAYS add it for testing
      const userId = user?._id || user?.id;
      console.log('🤖 MessagesPage: Avatar conversation check:', { 
        avatarConversation: !!avatarConversation, 
        user: !!user,
        userId_id: user?._id,
        userId_alt: user?.id,
        finalUserId: userId,
        conversationsCount: allConversationsUnified.length 
      });
      
      // Force create avatar conversation if user exists (for testing)
      if (userId) {
        const testAvatarId = `avatar_conversation_${userId}`;
        const alreadyExists = allConversationsUnified.some(conv => conv._id === testAvatarId);
        
        console.log('🤖 MessagesPage: Force adding avatar conversation, already exists:', alreadyExists);
        
        if (!alreadyExists) {
          const forceAvatarConv = {
            _id: testAvatarId,
            name: 'Avatar',
            type: 'dm',
            conversationType: 'ai_avatar',
            isPermanent: true,
            alwaysOnTop: true,
            lastMessage: {
              text: 'Hi! I\'m your AI Avatar assistant. Ask me anything about TipTop!',
              senderId: 'avatar_system_user',
              senderName: 'Avatar',
              timestamp: new Date().toISOString()
            },
            lastMessageAt: new Date().toISOString(),
            unread: 0,
            members: [
              {
                _id: userId,
                fullName: user.fullName || user.username,
                username: user.username,
                email: user.email
              },
              {
                _id: 'avatar_system_user',
                fullName: 'Avatar',
                username: 'avatar',
                userType: 'ai_avatar',
                isSystem: true
              }
            ],
            settings: {
              isAvatarConversation: true,
              aiEnabled: true
            },
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          
          // Always place avatar conversation at the very top
          allConversationsUnified = [forceAvatarConv, ...allConversationsUnified];
          console.log('🤖 MessagesPage: FORCE added avatar conversation, new count:', allConversationsUnified.length);
        }
      }
      
      // Use a single section for all conversations
      const unifiedSection = [
        { section: 'All Conversations', icon: MessageCircle, items: allConversationsUnified }
      ];
      
      // Smart merge: preserve higher local unread counts from real-time updates
      setAllConversations(prevSections => {
        const newSections = [...unifiedSection];
        
        // If we have previous data, merge unread counts intelligently
        if (prevSections.length > 0 && prevSections[0].items) {
          const prevItems = prevSections[0].items;
          
          newSections[0].items = newSections[0].items.map(newConv => {
            const prevConv = prevItems.find(p => p._id === newConv._id);
            if (prevConv && prevConv.unread > newConv.unread) {
              // Keep the higher local unread count (from real-time updates)
              return { ...newConv, unread: prevConv.unread };
            }
            return newConv;
          });
        }
        
        return newSections;
      });

      // Prefetch the first few messages for a subset of conversations to improve perceived loading times.
      // We limit the number of conversations prefetched per section to avoid overwhelming the server.
      const PREFETCH_CONVERSATIONS_PER_SECTION = 3;
      const PREFETCH_MESSAGES_LIMIT = 10;
      const conversationsToPrefetch = conversations.slice(0, PREFETCH_CONVERSATIONS_PER_SECTION);
      
      // FIXED: Smart prefetch that never overwrites real-time cached messages
      conversationsToPrefetch.forEach(conv => {
        if (!conv || !conv._id) return;
        
        // Skip prefetching for avatar conversations - they're client-side only
        if (conv.conversationType === 'ai_avatar' || conv.settings?.isAvatarConversation) {
          return;
        }
        
        // Only prefetch if NO cache exists at all (empty or undefined)
        const existingCache = messagesCache[conv._id];
        if (!existingCache || existingCache.length === 0) {
          messageAPI.getMessages(conv._id, { limit: PREFETCH_MESSAGES_LIMIT })
            .then(res => {
              const msgs = (res.data?.messages || res.data || []).reverse(); // Reverse since API now returns newest first
              // Only update cache if it's still empty (avoid overwriting real-time messages)
              setMessagesCache(prev => {
                if (prev[conv._id] && prev[conv._id].length > 0) {
                  return prev;
                }
                return { ...prev, [conv._id]: msgs };
              });
            })
            .catch(err => {
              console.warn(`Prefetch messages for conversation ${conv._id} failed:`, err);
            });
        }
      });
      
      // Auto-selection removed - let user choose which conversation to open
      // if (conversations.length > 0 && !selected && !selectedRef.current && allConversations.length === 0) {
      //   handleSelect(conversations[0]);
      // }
    } catch (error) {
      console.error('Error fetching conversations:', error);
    }
  }, [messagesCache, avatarConversation, pinnedConversations]);
  
  // Keep refs in sync with state
  useEffect(() => {
    selectedRef.current = selected;
  }, [selected]);

  // Track entering/leaving messages page
  useEffect(() => {
    updateMessagesPageStatus(true);
    
    // Only refresh on entry if we don't have conversations loaded yet
    if (allConversations.length === 0) {
      fetchConversations();
    }
    
    return () => {
      updateMessagesPageStatus(false);
      clearCurrentConversation();
    };
  }, [updateMessagesPageStatus, clearCurrentConversation, fetchConversations, allConversations.length]);

  // Update current conversation when selected conversation changes
  useEffect(() => {
    if (selected?._id) {
      updateCurrentConversation(selected._id);
      clearNotificationsForConversation(selected._id);
    } else {
      clearCurrentConversation();
    }
  }, [selected?._id, updateCurrentConversation, clearCurrentConversation, clearNotificationsForConversation]);

  // Debounced function to mark conversation as read (prevents API spam)
  const debouncedMarkAsRead = useCallback((conversationId) => {
    if (!conversationId) return;

    // Clear any existing timeout to debounce rapid calls
    if (markReadTimeoutRef.current) {
      clearTimeout(markReadTimeoutRef.current);
    }

    // Debounce the API call by 500ms
    markReadTimeoutRef.current = setTimeout(() => {
      // Skip if already marked as read very recently (within last 2 seconds)
      if (readConversationsRef.current.has(conversationId)) {
        return;
      }
      
      // Add to read set to prevent duplicates
      readConversationsRef.current.add(conversationId);
      
      console.log('📖 Marking conversation as read:', conversationId);
      conversationAPI.markConversationAsRead(conversationId)
        .then(() => {
          console.log('📖 Successfully marked conversation as read:', conversationId);
          if (refreshUnreadCount) refreshUnreadCount();
          
          // Set unread to 0 for this conversation in the sidebar
          setAllConversations(prev =>
            prev.map(section => ({
              ...section,
              items: section.items.map(conv => 
                conv._id === conversationId 
                  ? { ...conv, unread: 0 }
                  : conv
              )
            }))
          );
          
          // Remove from set after 3 seconds to allow re-marking if needed
          setTimeout(() => {
            readConversationsRef.current.delete(conversationId);
          }, 3000);
        })
        .catch(error => {
          console.error('Error marking conversation as read:', error);
          // Remove from set on error so it can be retried
          readConversationsRef.current.delete(conversationId);
        });
    }, 300); // Reduced debounce time for more responsive feeling
  }, [refreshUnreadCount, setAllConversations]);
  
  useEffect(() => {
    messagesCacheRef.current = messagesCache;
    
    // Persist cache to localStorage for page reload persistence
    try {
      localStorage.setItem('messagesCache', JSON.stringify(messagesCache));
    } catch (error) {
      console.warn('Failed to persist messages cache to localStorage:', error);
    }
  }, [messagesCache]);
  
  useEffect(() => {
    allConversationsRef.current = allConversations;
  }, [allConversations]);
  
  // Persist pinned conversations to localStorage
  useEffect(() => {
    try {
      localStorage.setItem('pinnedConversations', JSON.stringify(pinnedConversations));
    } catch (error) {
      console.error('Error saving pinned conversations to localStorage:', error);
    }
  }, [pinnedConversations]);
  
  // Persist avatar messages to localStorage
  useEffect(() => {
    try {
      // Convert Map to object for JSON serialization
      const avatarMessagesObj = Object.fromEntries(avatarMessages);
      localStorage.setItem('avatarMessages', JSON.stringify(avatarMessagesObj));
      console.log('🤖 MessagesPage: Persisted avatar messages to localStorage:', avatarMessagesObj);
    } catch (error) {
      console.error('Error saving avatar messages to localStorage:', error);
    }
  }, [avatarMessages]);
  
  // Search functionality
  const [showSearch, setShowSearch] = useState(false);
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [currentSearchResult, setCurrentSearchResult] = useState(0);
  const [totalSearchResults, setTotalSearchResults] = useState(0);
  const [searchFilters, setSearchFilters] = useState(null);
  const [reactionInProgress, setReactionInProgress] = useState(false);
  const [pinnedMessages, setPinnedMessages] = useState([]);
  const [starredMessages, setStarredMessages] = useState([]);
  const [hasMoreMessages, setHasMoreMessages] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [messageOffset, setMessageOffset] = useState(0);
  
  const [draftMessages, setDraftMessages] = useState(() => {
    try {
      const saved = localStorage.getItem('draftMessages');
      return saved ? JSON.parse(saved) : {};
    } catch {
      return {};
    }
  });

  /**
   * Move a conversation to the top of its section in the sidebar.
   * This helper updates the conversation's `lastMessage` and `lastMessageAt` fields
   * and reorders the items array for the corresponding section so that the most 
   * recently active conversation appears first.
   *
   * @param {string} convId - The ID of the conversation to move.
   * @param {object} lastMessage - The last message object with text, file, createdAt, senderName.
   * @param {string} time - ISO timestamp of when the activity occurred.
   */
  const moveConversationToTop = useCallback((convId, lastMessage, time, incrementUnread = false) => {
    setAllConversations(prevSections => {
      const newSections = [...prevSections];
      // With unified structure, we work with the first (and only) section
      const sectionIndex = 0;
      
      if (sectionIndex < newSections.length) {
        const section = newSections[sectionIndex];
        const idx = section.items.findIndex(c => c._id === convId);
        
        if (idx !== -1) {
          const newItems = [...section.items];
          const [convItem] = newItems.splice(idx, 1);
          
          const oldUnread = convItem.unread || 0;
          const newUnread = incrementUnread ? oldUnread + 1 : oldUnread;
          
          if (incrementUnread) {
            console.log(`📬 Incrementing unread count for ${convItem.name || convId}: ${oldUnread} → ${newUnread}`);
          }

          const updatedConv = {
            ...convItem,
            lastMessage: { 
              ...lastMessage,
              _forceUpdate: Date.now()
            },
            lastMessageAt: time,
            unread: newUnread,
            _lastUpdated: Date.now()
          };

          // Re-sort all items by most recent activity after updating (keeping avatar at top)
          const allItemsUpdated = sortConversationsWithAvatarTop([updatedConv, ...newItems]);

          newSections[sectionIndex] = {
            ...section,
            items: allItemsUpdated,
            _lastUpdated: Date.now()
          };
        }
      }

      return newSections;
    });
  }, []);

  // Add new conversation to top of sidebar (similar to moveConversationToTop but for new conversations)
  const addConversationToTop = useCallback((newConversation) => {
    setAllConversations(prevSections => {
      const newSections = [...prevSections];
      // With unified structure, we work with the first (and only) section
      const sectionIndex = 0;
      
      // Ensure section exists
      if (sectionIndex >= newSections.length) {
        newSections.push({
          section: 'All Conversations',
          icon: 'MessageCircle',
          items: []
        });
      }
      
      const section = newSections[sectionIndex];
      
      // Check if conversation already exists
      const existingIndex = section.items.findIndex(c => c._id === newConversation._id);
      if (existingIndex !== -1) {
        return prevSections;
      }
      
      // Create conversation object with all required fields
      const conversationToAdd = {
        _id: newConversation._id,
        name: newConversation.name,
        type: newConversation.type,
        members: newConversation.members || [],
        admins: newConversation.admins || [],
        createdBy: newConversation.createdBy,
        createdAt: newConversation.createdAt || new Date().toISOString(),
        updatedAt: newConversation.updatedAt || new Date().toISOString(),
        description: newConversation.description || null,
        unread: 0,
        lastMessage: null,
        lastMessageAt: newConversation.createdAt || new Date().toISOString(),
        _lastUpdated: Date.now() // This triggers re-render
      };
      
      
      // Add to top and re-sort by most recent activity (keeping avatar at top)
      const allItemsUpdated = sortConversationsWithAvatarTop([conversationToAdd, ...section.items]);
      
      newSections[sectionIndex] = {
        ...section,
        items: allItemsUpdated,
        _lastUpdated: Date.now() // This triggers re-render
      };
      
      return newSections;
    });
  }, []);

  // Request notification permission on mount
  useEffect(() => {
    if (window.Notification && Notification.permission === 'default') {
      Notification.requestPermission();
    }
    // Track window focus
    const onFocus = () => (windowFocused.current = true);
    const onBlur = () => (windowFocused.current = false);
    
    // Handle visibility change to refresh conversations when page becomes visible
    const onVisibilityChange = () => {
      if (!document.hidden) {
        // Only refresh if page was hidden for more than 30 seconds
        const hiddenTime = Date.now() - (document.lastVisibilityChange || 0);
        if (hiddenTime > 30000) {
          console.log('🔄 Page visible after long absence, refreshing conversations');
          setTimeout(() => {
            fetchConversations(true); // Force refresh after long absence
          }, 1000);
        }
      } else {
        document.lastVisibilityChange = Date.now();
      }
    };
    
    window.addEventListener('focus', onFocus);
    window.addEventListener('blur', onBlur);
    document.addEventListener('visibilitychange', onVisibilityChange);
    
    return () => {
      window.removeEventListener('focus', onFocus);
      window.removeEventListener('blur', onBlur);
      document.removeEventListener('visibilitychange', onVisibilityChange);
    };
  }, [fetchConversations]);

  // Capture URL conversation parameter immediately on mount for notification navigation
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const conversationId = urlParams.get('conversation');
    if (conversationId) {
      console.log('📱 Notification navigation: Found conversation ID in URL:', conversationId);
      setPendingConversationId(conversationId);
      // Clear URL parameter to prevent it from interfering with navigation
      window.history.replaceState({}, document.title, window.location.pathname);
    }
  }, []);

  // Fetch conversations on mount (REST)
  useEffect(() => {
    fetchConversations();
  }, []);

  // When mounting on mobile, show sidebar first
  useEffect(() => {
    if (isMobile) {
      setSidebarOpen(true);
      setSelected(null);
    }
  }, [isMobile]);

  // Handle pending conversation selection from notifications
  useEffect(() => {
    // Check for pending conversation ID first (from notification navigation)
    const conversationId = pendingConversationId || new URLSearchParams(window.location.search).get('conversation');
    
    if (conversationId && allConversations.length > 0) {
      const allItems = allConversations.flatMap(section => section.items);
      const target = allItems.find(c => c._id === conversationId);
      if (target) {
        console.log('📱 Selecting conversation from notification/URL:', conversationId);
        
        // Clear cache for conversations with unread messages or accessed via URL to ensure fresh data
        if ((target.unread && target.unread > 0) || pendingConversationId) {
          console.log('📱 Clearing cache for fresh message loading - unread:', target.unread, 'fromURL:', !!pendingConversationId);
          setMessagesCache(prev => ({
            ...prev,
            [conversationId]: []
          }));
        }
        
        setSelected(target);
        if (isMobile) setSidebarOpen(false);
        
        // Mark conversation as read when navigating from notification
        if (target.unread > 0) {
          setAllConversations(prev =>
            prev.map(section => ({
              ...section,
              items: section.items.map(conversation => 
                conversation._id === target._id 
                  ? { ...conversation, unread: 0 }
                  : conversation
              )
            }))
          );
          debouncedMarkAsRead(target._id);
        }
        
        // Clear pending conversation ID and URL param
        setPendingConversationId(null);
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    }
  }, [allConversations, isMobile, debouncedMarkAsRead, pendingConversationId]);

  // Initialize message queue and status services
  useEffect(() => {
    // Set up the message sender function for the queue
    messageQueue.setMessageSender(async (messageData) => {
      const response = await chatSocket.sendMessage({
        conversationId: messageData.conversationId,
        text: messageData.text,
        file: messageData.file,
        replyTo: messageData.replyTo,
        tempId: messageData.tempId,
      });
      
      if (response && response.success) {
        try {
          // Small delay to ensure other processing completes
          setTimeout(() => {
            if (messageStatus && typeof messageStatus.markAsSent === 'function') {
              messageStatus.markAsSent(messageData.tempId, response.messageId);
            }
          }, 50);
        } catch (error) {
          console.error('Error marking message as sent in queue:', error);
        }
      }
      
      return response;
    });

    // Set up socket connection checker for the queue
    messageQueue.setSocketChecker(() => chatSocket.connected);

    // Listen for queue events
    const unsubscribeQueue = messageQueue.addListener((event) => {
      
      switch (event.type) {
        case 'messageRetrySuccess':
          setNotification({
            message: 'Message sent successfully!'
          });
          setTimeout(() => setNotification(null), 2000);
          break;
          
        case 'messageRetryFailed':
          try {
            if (messageStatus && typeof messageStatus.markAsFailed === 'function') {
              messageStatus.markAsFailed(event.tempId, event.error);
            }
          } catch (error) {
            console.error('Error marking message as failed:', error);
          }
          setNotification({
            message: 'Message failed to send. Check your connection.'
          });
          setTimeout(() => setNotification(null), 3000);
          break;
          
        case 'network':
          if (event.online) {
            setNotification({
              message: 'Connection restored. Sending queued messages...'
            });
            setTimeout(() => setNotification(null), 2000);
          }
          break;
      }
    });

    // Listen for status changes to update UI
    const unsubscribeStatus = messageStatus.addListener((event) => {
      
      // Force re-render when status changes
      setMessages(prev => [...prev]);
    });

    // Listen for socket connection to process queues when actually connected
    const handleSocketConnect = () => {
      setTimeout(() => {
        messageQueue.processQueues();
      }, 1000); // Small delay to ensure rooms are joined
    };

    if (chatSocket.socket) {
      chatSocket.on('connect', handleSocketConnect);
    }

    // Process any existing queues on mount
    messageQueue.processQueues();

    // Cleanup
    return () => {
      unsubscribeQueue();
      unsubscribeStatus();
      if (chatSocket.socket) {
        chatSocket.off('connect', handleSocketConnect);
      }
    };
  }, [chatSocket]);

  // Global retry function for failed messages
  useEffect(() => {
    window.retryMessage = (tempId) => {
      const queuedMessages = messageQueue.getQueuedMessages(selected?._id);
      const messageToRetry = queuedMessages.find(msg => msg.tempId === tempId);
      
      if (messageToRetry) {
        try {
          console.log('Retrying message:', tempId);
          
          // Remove from failed queue if it's there
          messageQueue.removeFromQueues(tempId);
          
          // Add to retry queue with reset attempt count
          if (messageQueue && typeof messageQueue.addToRetryQueue === 'function') {
            messageQueue.addToRetryQueue(messageToRetry, 0); // Reset retry count
          }
          
          // Update message status
          if (messageStatus && typeof messageStatus.setMessageStatus === 'function') {
            messageStatus.setMessageStatus(tempId, MESSAGE_STATUS.SENDING);
          }
          
          // Update UI to show sending state
          setMessages(prev => prev.map(msg => 
            msg.tempId === tempId 
              ? { ...msg, failed: false, sending: true, pending: false }
              : msg
          ));
          
          // Process the queues
          if (messageQueue && typeof messageQueue.processQueues === 'function') {
            messageQueue.processQueues();
          }
        } catch (error) {
          console.error('Error retrying message:', error);
        }
      } else {
        console.log('Message not found in queue for retry:', tempId);
      }
    };

    return () => {
      delete window.retryMessage;
    };
  }, [selected]);

  // WHATSAPP-STYLE: Instant Conversation Loading  
  useEffect(() => {
    if (!selected?._id) {
      setMessages([]);
      setMessagesLoading(false);
      setMessageOffset(0);
      setHasMoreMessages(true);
      setLoadingMore(false);
      return;
    }
    
    const convId = selected._id;
    
    // CRITICAL: Check for avatar conversations FIRST before doing any message clearing/loading
    // Avatar conversations use their own storage system and should skip the regular message loading flow
    if (isAvatarConversation && isAvatarConversation(selected)) {
      console.log('🤖 MessagesPage: useEffect detected avatar conversation, skipping regular message loading flow');
      setMessageOffset(0);
      setHasMoreMessages(false); // Avatar conversations don't use pagination
      setLoadingMore(false);
      // Reset conversation switch flag immediately
      setTimeout(() => {
        setIsConversationSwitch(false);
      }, 50);
      return; // Exit early - avatar messages are handled by handleSelect function
    }
    
    // Always fetch fresh messages from server, but show cached ones immediately for better UX
    // Use ref to get the most current cache (important for navigation from notifications)
    const cachedMessages = messagesCacheRef.current[convId] || [];
    
    // Immediately set the correct messages for this conversation (no delay, no flicker)
    if (cachedMessages.length > 0) {
      // Validate that cached messages belong to this conversation
      const validMessages = cachedMessages.filter(msg => 
        msg.conversationId === convId || msg.conversation === convId
      );
      
      if (validMessages.length > 0) {
        // Show cached messages instantly for WhatsApp-like experience
        setMessages(validMessages);
        setMessagesLoading(false);
      } else {
        // Invalid cache - show loading
        setMessages([]);
        setMessagesLoading(true);
        console.log('⚠️ Invalid cached messages, showing loading for conversation:', convId);
      }
      
      // Set up unread indicators and reactions from cache
      const unreadCount = selected.unread || 0;
      if (unreadCount > 0 && cachedMessages.length >= unreadCount) {
        const unreadStart = cachedMessages.length - unreadCount;
        setUnreadStartIndex(unreadStart);
      } else {
        setUnreadStartIndex(null);
      }
      
      const cachedReactions = {};
      cachedMessages.forEach(msg => {
        if (msg.reactions && msg.reactions.length > 0) {
          cachedReactions[msg._id] = msg.reactions;
        }
      });
      setReactions(cachedReactions);
      
      // Reset conversation switch flag immediately after showing cached messages
      setTimeout(() => {
        setIsConversationSwitch(false);
      }, 50);
    } else {
      // No cache - show loading state
      setMessages([]);
      setMessagesLoading(true);
      setReactions({});
      console.log('⏳ No cached messages, showing loading for conversation:', convId);
    }
    
    // Always fetch from server in background to ensure we have latest messages
    // Note: Avatar conversations are already handled at the beginning of this useEffect
    
    messageAPI.getMessages(convId, { limit: 50 })
      .then(res => {
        // SAFETY CHECK: Only process if this is still the selected conversation
        if (selected?._id !== convId) {
          console.log('🚫 Ignoring server response for old conversation:', convId, 'current:', selected?._id);
          return;
        }

        // Double check with selectedRef to ensure we haven't switched conversations during the async operation
        if (selectedRef.current?._id !== convId) {
          console.log('🚫 Ignoring server response - conversation changed during fetch:', convId, 'current:', selectedRef.current?._id);
          return;
        }
        
        const serverMessages = (res.data.messages || []).reverse(); // Reverse since API now returns newest first
        
        // Validate server messages belong to this conversation
        const validServerMessages = serverMessages.filter(msg => 
          msg.conversation === convId || msg.conversationId === convId
        );
        
        // Only merge if we have cached messages that might contain newer real-time messages
        // Otherwise, just use server messages directly to avoid potential duplication
        let finalMessages;
        if (cachedMessages.length > 0) {
          finalMessages = mergeMessages(validServerMessages, cachedMessages);
        } else {
          finalMessages = validServerMessages;
        }
        
        // Final validation before setting messages
        const validFinalMessages = finalMessages.filter(msg => 
          msg.conversationId === convId || msg.conversation === convId
        );
        
        setMessages(validFinalMessages);
        
        // Force a state update to ensure messages are applied even with React batching
        setTimeout(() => {
          if (selectedRef.current?._id === convId) {
            setMessages(prevMessages => {
              if (prevMessages.length !== validFinalMessages.length) {
                console.log('🔧 Force-updating messages state - was:', prevMessages.length, 'should be:', validFinalMessages.length);
                return validFinalMessages;
              }
              return prevMessages;
            });
          }
        }, 0);
        
        setMessageOffset(finalMessages.length);
        setHasMoreMessages(serverMessages.length === 50);
        
        // Recalculate unread indicator position for server messages
        const unreadCount = selected.unread || 0;
        if (unreadCount > 0 && finalMessages.length >= unreadCount) {
          const unreadStart = finalMessages.length - unreadCount;
          setUnreadStartIndex(unreadStart);
        } else {
          setUnreadStartIndex(null);
        }
        
        // Initialize reactions state from loaded messages
        const initialReactions = {};
        finalMessages.forEach(msg => {
          if (msg.reactions && msg.reactions.length > 0) {
            initialReactions[msg._id] = msg.reactions;
          }
        });
        setReactions(initialReactions);
        
        // Update cache with final results
        setMessagesCache(prev => ({
          ...prev,
          [convId]: finalMessages
        }));
        
        chatSocket.joinConversation(convId);
        
        // Reset conversation switch flag after messages are loaded
        setTimeout(() => {
          setIsConversationSwitch(false);
        }, 100); // Small delay to ensure scroll happens first
      })
      .catch(error => {
        console.error('Failed to load messages:', error);
        // If server fetch fails, keep cached messages if available
        if (cachedMessages.length === 0) {
          setMessages([]);
        }
        chatSocket.joinConversation(convId);
        
        // Reset flag even on error
        setTimeout(() => {
          setIsConversationSwitch(false);
        }, 100);
      })
      .finally(() => {
        setMessagesLoading(false);
      });
    
    // Always leave previous room when switching
    return () => {
      chatSocket.leaveConversation(convId);
    };
  }, [selected?._id]); // Only re-run when conversation ID changes, not when selected object changes

  // Debug: Track messages state changes
  useEffect(() => {
  }, [messages, selected?._id]);

  // REMOVED: Complex cache-sync logic - WhatsApp approach handles this directly in the message handler

  // WHATSAPP-STYLE: Simple, Reliable Real-time Handler
  useEffect(() => {
    if (!chatSocket.socket) return;
    
    const handleNewMessage = (msg) => {
      const conversationId = msg.conversationId || msg.conversation;
      const isMyMessage = msg.senderId === user.id;
      const isCurrentConversation = selectedRef.current?._id === conversationId;
      
      console.log(`📨 Received chat:new message:`, msg._id);
      console.log(`📨 Message details - From: ${msg.senderName || msg.senderId}, isMyMessage: ${isMyMessage}, currentConv: ${isCurrentConversation}`);
      console.log(`📨 Will increment unread: ${!isMyMessage && !isCurrentConversation}`);
      
      
      // 1. ALWAYS Update message cache (regardless of current conversation)
      setMessagesCache(prev => {
        const convMessages = prev[conversationId] || [];
        
        // Skip if message already exists (by _id) - but don't skip if this is a server message replacing an optimistic one
        const isDuplicate = convMessages.some(m => {
          // Skip if we already have this exact server message (by _id)
          if (m._id && msg._id && m._id === msg._id) {
            return true;
          }
          return false;
        });
        if (isDuplicate) {
          return prev;
        }
        
        // ALWAYS remove optimistic duplicates from cache (whether current conversation or not)
        let cleanMessages = convMessages;
        if (isMyMessage) {
          
          // Find and remove ALL potential duplicates of this message
          cleanMessages = convMessages.filter(m => {
            // Remove if tempIds match (this optimistic message is being replaced)
            if (msg.tempId && m.tempId === msg.tempId) {
              return false;
            }
            
            // Remove if it's a pending/sending message from this user with same tempId
            if (msg.tempId && m.senderId === user.id && (m.pending || m.sending) && m.tempId === msg.tempId) {
              return false;
            }
            
            // Critical: Remove ANY temp message from same user with same text (regardless of timestamp)
            // This handles the case where server message doesn't have tempId
            if (m.senderId === user.id && m.text === msg.text && 
                (m._id?.startsWith('temp-') || m.tempId || m.pending || m.sending)) {
              return false;
            }
            
            // Remove ANY message from same user with same text and recent timestamp (within 5 minutes)
            if (m.senderId === user.id && m.text === msg.text) {
              const timeDiff = Math.abs(new Date(m.createdAt || m.timestamp) - new Date(msg.createdAt));
              if (timeDiff < 300000) { // 5 minutes window to catch all edge cases
                return false;
              }
            }
            
            return true;
          });
          
        }
        
        
        const newCache = [...cleanMessages, { ...msg, conversationId }];
        // Limit cache size per conversation to prevent localStorage overflow
        const MAX_CACHED_MESSAGES = 50;
        const limitedCache = newCache.length > MAX_CACHED_MESSAGES 
          ? newCache.slice(-MAX_CACHED_MESSAGES)
          : newCache;
        
        return {
          ...prev,
          [conversationId]: limitedCache
        };
      });
      
      // 2. Update current conversation view if active
      if (isCurrentConversation) {
        setMessages(prev => {
          
          // Enhanced deduplication logic
          let filtered = prev;
          const initialCount = filtered.length;
          
          // First, remove any duplicates by _id (exact matches)
          if (msg._id) {
            const beforeCount = filtered.length;
            filtered = filtered.filter(m => m._id !== msg._id);
            if (filtered.length < beforeCount) {
              console.log('🗑️ Removed duplicate by _id:', msg._id, `(${beforeCount} → ${filtered.length})`);
            }
          }
          
          // Second, remove optimistic messages that this server message replaces
          if (msg.tempId) {
            const beforeCount = filtered.length;
            filtered = filtered.filter(m => {
              // Remove optimistic message with matching tempId
              if (m.tempId === msg.tempId && (!m._id || m._id.startsWith('temp-'))) {
                console.log('🗑️ Removing optimistic message by tempId:', m.tempId, 'for real message:', msg._id);
                return false;
              }
              return true;
            });
            if (filtered.length < beforeCount) {
              console.log('🗑️ Removed optimistic messages by tempId:', msg.tempId, `(${beforeCount} → ${filtered.length})`);
            }
          }
          
          // Third, for sent messages, remove ALL temp/optimistic messages with same content (aggressive cleanup)
          if (isMyMessage) {
            const beforeCount = filtered.length;
            filtered = filtered.filter(m => {
              // Remove ANY temp message from same user with same text (regardless of timestamp or tempId)
              if (m.senderId === user.id && m.text === msg.text && 
                  (m._id?.startsWith('temp-') || m.tempId || m.pending || m.sending)) {
                console.log('🗑️ Removing temp/optimistic by content:', m._id || m.tempId, '→', msg._id);
                return false;
              }
              
              // Remove ANY message from same user with same text and recent timestamp (within 5 minutes)
              if (m.senderId === user.id && m.text === msg.text) {
                const timeDiff = Math.abs(new Date(m.createdAt || m.timestamp) - new Date(msg.createdAt));
                if (timeDiff < 300000) { // 5 minutes window
                  console.log('🗑️ Removing similar by content + time:', m._id || m.tempId, 'timeDiff:', timeDiff + 'ms', '→', msg._id);
                  return false;
                }
              }
              
              return true;
            });
            if (filtered.length < beforeCount) {
              console.log('🗑️ Removed', beforeCount - filtered.length, 'temp/similar messages for:', msg._id);
            }
          }
          
          const newMessage = { 
            ...msg, 
            conversationId,
            // Ensure these fields are properly set for rendering
            pending: false,
            sending: false
          };
          const newMessages = [...filtered, newMessage];
          return newMessages;
        });
        
        // Update reactions state if the new message has reactions
        if (msg.reactions && msg.reactions.length > 0) {
          setReactions(prev => ({
            ...prev,
            [msg._id]: msg.reactions
          }));
        }
      }
      
      // 3. Update sidebar
      moveConversationToTop(
        conversationId,
        {
          text: msg.text,
          file: msg.file,
          createdAt: msg.createdAt || new Date().toISOString(),
          senderName: msg.senderName || (isMyMessage ? 'You' : 'Unknown')
        },
        msg.createdAt || new Date().toISOString(),
        !isMyMessage && !isCurrentConversation // increment unread only for others' messages when not in that conversation
      );
      
      // 4. Browser notification (only for others' messages)
      if (!isMyMessage && window.Notification && Notification.permission === 'granted') {
        const title = msg.senderName || 'New Message';
        const body = msg.text || (msg.file ? 'Sent a file' : 'New message');
        new Notification(title, { body });
      }
    };
    
    chatSocket.on('chat:new', handleNewMessage);

    // Edit message
    chatSocket.on('chat:edit', ({ messageId, text, conversationId }) => {
      setMessages(prev => prev.map(m => m._id === messageId ? { ...m, text, edited: true } : m));
      
      // Move conversation to top when message is edited
      if (conversationId) {
        const editedMessage = messages.find(m => m._id === messageId);
        if (editedMessage) {
          moveConversationToTop(
            conversationId,
            {
              text: text,
              file: editedMessage.file,
              createdAt: editedMessage.createdAt,
              senderName: editedMessage.senderName || (editedMessage.sender && editedMessage.sender.fullName) || 'Unknown'
            },
            new Date().toISOString()
          );
        }
      }
    });
    // Delete message
    chatSocket.on('chat:delete', ({ messageId }) => {
      setMessages(prev => prev.filter(m => m._id !== messageId));
    });
    // React to message
    chatSocket.on('chat:react', ({ messageId, emoji, userId }) => {
      setMessages(prev => prev.map(m => m._id === messageId ? { ...m, reactions: [...(m.reactions || []), { user: userId, emoji }] } : m));
      setReactions(prev => ({
        ...prev,
        [messageId]: [...(prev[messageId] || []), { user: userId, emoji }]
      }));
    });
    // Unreact
    chatSocket.on('chat:unreact', ({ messageId, emoji, userId }) => {
      setMessages(prev => prev.map(m => m._id === messageId ? { ...m, reactions: (m.reactions || []).filter(r => !(r.user === userId && r.emoji === emoji)) } : m));
      setReactions(prev => ({
        ...prev,
        [messageId]: (prev[messageId] || []).filter(r => !(r.user === userId && r.emoji === emoji))
      }));
    });
    // Typing
    chatSocket.on('chat:typing', ({ userId: typingUserId, conversationId, typing }) => {
      if (typingUserId !== user.id && conversationId) {
        setTyping(prev => ({
          ...prev,
          [conversationId]: {
            ...prev[conversationId],
            [typingUserId]: typing
          }
        }));
      }
    });

    // Enhanced group membership events with real-time updates and notifications
    chatSocket.on('conversation:memberAdded', ({ 
      conversationId, 
      conversationName, 
      conversationType, 
      userId, 
      addedBy, 
      addedUser, 
      adderUser 
    }) => {
      console.log('🔥 [MEMBER-ADDED] Event received!');
      console.log('🔥 [MEMBER-ADDED] Data:', { conversationId, conversationName, conversationType, userId, addedBy, addedUser, adderUser });
      
      const currentUserId = user?.id;
      const isCurrentUser = userId === currentUserId;
      const isAdder = addedBy === currentUserId;
      
      console.log('🔥 [MEMBER-ADDED] Current user ID:', currentUserId);
      console.log('🔥 [MEMBER-ADDED] Is current user being added:', isCurrentUser);
      console.log('🔥 [MEMBER-ADDED] Is current user the adder:', isAdder);
      
      // If current user was added to the group, they should see it in their conversation list
      if (isCurrentUser) {
        
        // Refresh conversations to get the new group with updated members
        fetchConversations(true);
        
        // Show notification
        setNotification({
          message: `You were added to ${conversationName || 'a group'} by ${adderUser?.fullName || adderUser?.username || 'someone'}!`
        });
        setTimeout(() => setNotification(null), 4000);
        
        // Show browser notification if supported
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification('Added to Group', {
            body: `You were added to ${conversationName || 'a group'} by ${adderUser?.fullName || adderUser?.username || 'someone'}`,
            icon: '/favicon.ico'
          });
        }
      } else {
        // For other users, just update the current conversation if they're viewing it
        if (selected && selected._id === conversationId) {
          handleConversationUpdated();
        }
        
        // Show notification to existing members
        if (!isAdder) { // Don't show notification to the person who added someone
          setNotification({
            message: `${addedUser?.fullName || addedUser?.username || 'Someone'} was added to ${conversationName || 'the group'}`
          });
          setTimeout(() => setNotification(null), 3000);
        }
      }
    });

    chatSocket.on('conversation:memberRemoved', ({ 
      conversationId, 
      conversationName, 
      conversationType, 
      userId, 
      removedBy, 
      removedUser, 
      removerUser 
    }) => {
      console.log('🔥 [MEMBER-REMOVED] Event received!');
      console.log('🔥 [MEMBER-REMOVED] Data:', { conversationId, conversationName, conversationType, userId, removedBy, removedUser, removerUser });
      
      const currentUserId = user?.id;
      const isCurrentUser = userId === currentUserId;
      const isRemover = removedBy === currentUserId;
      
      console.log('🔥 [MEMBER-REMOVED] Current user ID:', currentUserId);
      console.log('🔥 [MEMBER-REMOVED] Is current user being removed:', isCurrentUser);
      console.log('🔥 [MEMBER-REMOVED] Is current user the remover:', isRemover);
      
      // If current user was removed from the group
      if (isCurrentUser) {
        console.log('🔥 [MEMBER-REMOVED] ❌ Current user was removed from group');
        
        // Remove conversation from sidebar immediately (similar to conversation:deleted)
        setAllConversations(prev => {
          const newSections = prev.map(section => ({
            ...section,
            items: section.items.filter(c => c._id !== conversationId),
            _lastUpdated: Date.now()
          }));
          
          console.log('🔥 [MEMBER-REMOVED] Updated sidebar sections - removed conversation');
          allConversationsRef.current = newSections;
          return newSections;
        });
        
        // If this was the selected conversation, clear selection
        if (selected && selected._id === conversationId) {
          console.log('🔥 [MEMBER-REMOVED] Clearing current selection');
          setSelected(null);
          selectedRef.current = null;
          setMessages([]);
        }
        
        // Remove from message cache
        setMessagesCache(prev => {
          const newCache = { ...prev };
          delete newCache[conversationId];
          return newCache;
        });
        
        // Show notification
        setNotification({
          message: `You were removed from ${conversationName || 'a group'} by ${removerUser?.fullName || removerUser?.username || 'an admin'}`
        });
        setTimeout(() => setNotification(null), 4000);
        
        // Show browser notification if supported
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification('Removed from Group', {
            body: `You were removed from ${conversationName || 'a group'} by ${removerUser?.fullName || removerUser?.username || 'an admin'}`,
            icon: '/favicon.ico'
          });
        }
      } else {
        // For other users, update the current conversation if they're viewing it
        if (selected && selected._id === conversationId) {
          handleConversationUpdated();
        }
        
        // Show notification to remaining members
        if (!isRemover) { // Don't show notification to the person who removed someone
          setNotification({
            message: `${removedUser?.fullName || removedUser?.username || 'Someone'} was removed from ${conversationName || 'the group'}`
          });
          setTimeout(() => setNotification(null), 3000);
        }
      }
    });

    chatSocket.on('conversation:adminAdded', ({ conversationId, userId, adminId }) => {
      console.log('🔔 Admin added to conversation:', { conversationId, userId, adminId });
      if (selected && selected._id === conversationId) {
        handleConversationUpdated();
      }
      // Removed fetchConversations() - socket events should handle updates
    });

    chatSocket.on('conversation:adminRemoved', ({ conversationId, userId, adminId }) => {
      console.log('🔔 Admin removed from conversation:', { conversationId, userId, adminId });
      if (selected && selected._id === conversationId) {
        handleConversationUpdated();
      }
      // Removed fetchConversations() - socket events should handle updates
    });

    // Real-time conversation creation events
    chatSocket.on('conversation:created', (newConversation) => {
      console.log('🔥 [CONVERSATION-CREATED] Event received!');
      console.log('🔥 [CONVERSATION-CREATED] Data:', JSON.stringify(newConversation, null, 2));
      const userId = user?.id;
      console.log('🔥 [CONVERSATION-CREATED] Current user ID:', userId);
      
      // For communities: visible to all users (no membership check)
      // For groups/DMs: require explicit membership
      const shouldShowConversation = newConversation.type === 'community' || 
                                    newConversation.members?.some(m => 
                                      (typeof m === 'string' ? m : m._id) === userId
                                    );
      
      console.log('🔥 [CONVERSATION-CREATED] Should show conversation:', shouldShowConversation);
      console.log('🔥 [CONVERSATION-CREATED] Conversation type:', newConversation.type);
      console.log('🔥 [CONVERSATION-CREATED] Members:', newConversation.members?.map(m => typeof m === 'string' ? m : m._id));
      
      // Always show conversation if user should see it (creator will have it from API, others get it from socket)
      if (shouldShowConversation) {
        
        // Use the same approach as chat:new messages - simple and effective!
        addConversationToTop(newConversation);
        
        setNotification({
          message: `You were added to ${newConversation.name || 'a new conversation'}!`
        });
        setTimeout(() => setNotification(null), 3000);
      } else {
        console.log('🔥 [CONVERSATION-CREATED] ❌ Not adding to sidebar - user is not a member');
      }
    });

    chatSocket.on('conversation:deleted', ({ conversationId, deletedBy, conversationName, conversationType }) => {
      console.log('🔥 [CONVERSATION-DELETED] Event received!');
      console.log('🔥 [CONVERSATION-DELETED] Data:', { conversationId, deletedBy, conversationName, conversationType });
      
      const isDeleter = deletedBy === user?.id;
      console.log('🔥 [CONVERSATION-DELETED] Is deleter:', isDeleter);
      
      // Remove conversation from sidebar for ALL users (same as creation - immediate update)
      console.log('🔥 [CONVERSATION-DELETED] Removing conversation from sidebar');
      setAllConversations(prev => {
        const newSections = prev.map(section => ({
          ...section,
          items: section.items.filter(c => c._id !== conversationId),
          _lastUpdated: Date.now() // Trigger re-render
        }));
        
        console.log('🔥 [CONVERSATION-DELETED] Updated sidebar sections');
        allConversationsRef.current = newSections;
        return newSections;
      });
      
      // If this was the selected conversation, clear selection
      if (selected && selected._id === conversationId) {
        console.log('🔥 [CONVERSATION-DELETED] Clearing current selection');
        setSelected(null);
        selectedRef.current = null;
        setMessages([]);
      }
      
      // Remove from message cache
      setMessagesCache(prev => {
        const newCache = { ...prev };
        delete newCache[conversationId];
        
        // Update localStorage
        try {
          localStorage.setItem('messagesCache', JSON.stringify(newCache));
        } catch (error) {
          console.error('Error updating localStorage cache:', error);
        }
        
        messagesCacheRef.current = newCache;
        return newCache;
      });
      
      // Show notification
      if (isDeleter) {
        setNotification({
          message: `${conversationName} deleted successfully`
        });
      } else {
        setNotification({
          message: `${conversationName} was deleted`
        });
      }
      setTimeout(() => setNotification(null), 3000);
      
      // Refresh unread count in header
      if (refreshUnreadCount) refreshUnreadCount();
    });

    return () => {
      chatSocket.off('chat:new');
      chatSocket.off('chat:edit');
      chatSocket.off('chat:delete');
      chatSocket.off('chat:react');
      chatSocket.off('chat:unreact');
      chatSocket.off('chat:typing');
      chatSocket.off('conversation:memberAdded');
      chatSocket.off('conversation:memberRemoved');
      chatSocket.off('conversation:adminAdded');
      chatSocket.off('conversation:adminRemoved');
      chatSocket.off('conversation:created');
      chatSocket.off('conversation:deleted');
    };
  }, [chatSocket.socket, user.id]);

  // Mark messages as read when conversation is selected
  useEffect(() => {
    if (selected && messages.length > 0) {
      // Mark all messages as read (only real messages, not temp ones)
      messages.forEach(msg => {
        if (msg.sender !== user.id && msg._id && !msg._id.startsWith('temp-')) {
          chatSocket.markAsRead(msg._id);
        }
      });
      
      // Only mark as read when user has actually interacted with the conversation
      // Don't auto-mark as read just for selecting - wait for user interaction
      // This prevents premature read marking that destroys unread indicators
    }
  }, [selected, user.id, chatSocket]); // Removed messages and allConversations to prevent aggressive read marking

  // Memoize conversation filtering to avoid expensive recalculations on each render.
  const filteredConversations = useMemo(() => {
    return allConversations.map(section => {
      const filteredItems = section.items.filter(conv => {
        try {
          const displayName = getConversationDisplayName(conv, user?._id || user?.id);
          
          const memberNames = Array.isArray(conv.members)
            ? conv.members.map(m => {
                if (typeof m === 'object' && m !== null) {
                  const name = m.fullName || m.username || m.email || '';
                  return String(name);
                }
                return '';
              }).join(' ')
            : '';
          
          const result = search
            ? displayName.toLowerCase().includes(search.toLowerCase()) || 
              memberNames.toLowerCase().includes(search.toLowerCase())
            : true;
          
          return result;
        } catch (error) {
          console.error('Error in conversation filter:', error);
          return false;
        }
      });
      
      return {
        ...section,
        items: filteredItems,
      };
    });
  }, [allConversations, search, user?._id, user?.id, forceUpdate]);

  const handleSelect = (conv) => {
    if (!conv || !conv._id) {
      return;
    }
    
    
    // Clear cache for conversations with unread messages to ensure fresh data
    if (conv.unread && conv.unread > 0) {
      console.log('📱 Clearing cache for conversation with unread messages:', conv.unread);
      setMessagesCache(prev => ({
        ...prev,
        [conv._id]: []
      }));
    }
    
    // CRITICAL: Clear messages immediately and show loading when user clicks
    setMessages([]);
    setMessagesLoading(true);
    
    // For avatar conversations, load saved messages or create welcome message
    if (isAvatarConversation && isAvatarConversation(conv)) {
      const savedMessages = avatarMessages.get(conv._id) || [];
      console.log('🤖 MessagesPage: Loading avatar conversation:', {
        conversationId: conv._id,
        savedMessagesCount: savedMessages.length,
        avatarMessagesMapSize: avatarMessages.size,
        allKeys: Array.from(avatarMessages.keys())
      });
      
      if (savedMessages.length > 0) {
        // Load saved conversation history
        console.log('🤖 MessagesPage: Loading saved avatar conversation:', conv._id, savedMessages.length, 'messages');
        setMessages(savedMessages);
        setMessagesLoading(false);
      } else {
        // Create initial welcome message for new avatar conversations
        const welcomeMessage = {
          _id: `welcome_${Date.now()}`,
          conversationId: conv._id,
          senderId: 'avatar_system_user',
          senderName: 'Avatar',
          text: 'Hi! I\'m your AI Avatar assistant. Ask me anything about TipTop!\n\nI can help you:\n✨ Find specific meeting transcripts\n🎥 Locate video segments\n📝 Answer questions about your content\n\nJust type your question and I\'ll search through all historical meetings to find relevant information!',
          createdAt: new Date().toISOString(),
          timestamp: new Date().toISOString(),
          isAvatarMessage: true,
          isWelcome: true,
          status: 'sent'
        };
        
        const initialMessages = [welcomeMessage];
        setMessages(initialMessages);
        setAvatarMessages(prev => {
          const newMap = new Map(prev);
          newMap.set(conv._id, initialMessages);
          return newMap;
        });
        setMessagesLoading(false);
      }
    }
    
    // Mark as conversation switch for instant scrolling
    setIsConversationSwitch(true);
    setSelected(conv);
    setReplyTo(null);
    setShowEmojiPicker(false);
    if (isMobile) setSidebarOpen(false);
    
    // Only mark as read if conversation has messages and user will see them
    // This preserves unread indicators until user actually views content
    if (conv.unread > 0) {
      // Immediately update UI to remove unread indicator for instant feedback
      setAllConversations(prev =>
        prev.map(section => ({
          ...section,
          items: section.items.map(conversation => 
            conversation._id === conv._id 
              ? { ...conversation, unread: 0 }
              : conversation
          )
        }))
      );
      
      // Mark as read on server in background (no delay needed for UI)
      debouncedMarkAsRead(conv._id);
      
      // Clear unread indicator since conversation is now read
      setUnreadStartIndex(null);
    }
  };

  // Send message with network resilience and retry logic
  const sendMessageWithRetry = async (messageData) => {
    try {
      // Check if we're online
      if (!navigator.onLine) {
        // Add to offline queue
        try {
          if (messageQueue && typeof messageQueue.addToOfflineQueue === 'function') {
            messageQueue.addToOfflineQueue(messageData);
          }
          if (messageStatus && typeof messageStatus.setMessageStatus === 'function') {
            messageStatus.setMessageStatus(messageData.tempId, MESSAGE_STATUS.SENDING);
          }
        } catch (error) {
          console.error('Error adding message to offline queue:', error);
        }
        return;
      }

      // Try to send the message
      const response = await chatSocket.sendMessage({
        conversationId: messageData.conversationId,
        text: messageData.text,
        file: messageData.file,
        replyTo: messageData.replyTo,
        tempId: messageData.tempId,
      });

      // Mark as sent if successful
      if (response && response.success) {
        try {
          if (messageQueue && typeof messageQueue.removeFromQueues === 'function') {
            messageQueue.removeFromQueues(messageData.tempId);
          }
          // Mark as sent immediately 
          if (messageStatus && typeof messageStatus.markAsSent === 'function') {
            messageStatus.markAsSent(messageData.tempId, response.messageId);
          }
        } catch (error) {
          console.error('Error updating message status:', error);
        }
      }

    } catch (error) {
      console.error('Message send failed:', error);
      
      // Add to retry queue for automatic retry
      try {
        if (messageQueue && typeof messageQueue.addToRetryQueue === 'function') {
          messageQueue.addToRetryQueue(messageData);
        }
        
        // Mark as failed temporarily (will be updated when retry succeeds)
        if (messageStatus && typeof messageStatus.setMessageStatus === 'function') {
          messageStatus.setMessageStatus(messageData.tempId, MESSAGE_STATUS.SENDING);
        }
      } catch (error) {
        console.error('Error queueing message for retry:', error);
      }
      
      throw error; // Re-throw to handle in calling function
    }
  };

  // Send a new message. This version implements an "optimistic" update so the message
  // Enhanced handleSend with optimistic UI and loading states
  const handleSend = async () => {
    console.log('🤖 MessagesPage: handleSend called, input:', input.trim());
    console.log('🤖 MessagesPage: selected conversation:', selected?._id, selected?.name);
    console.log('🤖 MessagesPage: isAvatarConversation check:', isAvatarConversation && isAvatarConversation(selected));
    
    // Check if a conversation is selected and has an _id
    if (!selected || !selected._id) {
      return;
    }

    // Check if there's input to send
    if (!input.trim() && !uploadFile) {
      return;
    }

    // Prevent multiple sends
    if (isSending) {
      return;
    }

    // Special handling for avatar conversations - act like a chatbot
    if (isAvatarConversation && isAvatarConversation(selected)) {
      console.log('🤖 MessagesPage: Handling avatar conversation message (chatbot mode)');
      setIsSending(true);
      
      try {
        // Clear input immediately for better UX
        const messageText = input.trim();
        setInput('');
        setReplyTo(null);
        
        // Create user message and add it immediately to the chat
        const userId = user?._id || user?.id;
        const userMessage = {
          _id: `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          conversationId: selected._id,
          senderId: userId,
          senderName: user?.fullName || user?.username || 'You',
          text: messageText,
          createdAt: new Date().toISOString(),
          timestamp: new Date().toISOString(),
          isAvatarMessage: false,
          status: 'sent',
          // Explicitly set sending-related properties to false
          sending: false,
          pending: false,
          // Don't set tempId to avoid message status system tracking
          tempId: null,
          // Mark as avatar conversation user message to bypass normal processing
          isAvatarConversationMessage: true
        };
        
        console.log('🤖 MessagesPage: Created user message for avatar conversation:', userMessage);
        
        // Add user message immediately to the chat
        setMessages(prevMessages => {
          const newMessages = [...prevMessages, userMessage];
          // Save to avatar messages storage
          setAvatarMessages(prev => {
            const newMap = new Map(prev);
            newMap.set(selected._id, newMessages);
            return newMap;
          });
          return newMessages;
        });
        
        // Add typing indicator for avatar
        const typingMessage = {
          _id: `typing_${Date.now()}`,
          conversationId: selected._id,
          senderId: 'avatar_system_user',
          senderName: 'Avatar',
          text: 'Thinking...',
          createdAt: new Date().toISOString(),
          timestamp: new Date().toISOString(),
          isAvatarMessage: true,
          isTyping: true,
          status: 'typing'
        };
        
        setMessages(prevMessages => {
          const newMessages = [...prevMessages, typingMessage];
          // Save to avatar messages storage (including typing indicator temporarily)
          setAvatarMessages(prev => {
            const newMap = new Map(prev);
            newMap.set(selected._id, newMessages);
            return newMap;
          });
          return newMessages;
        });
        
        // Process avatar response asynchronously using direct API calls (like MeetingPage)
        console.log('🤖 MessagesPage: Processing avatar query:', messageText);
        
        try {
          // Direct API call to bot service (no conversation management needed)
          const { success, data, error } = await BotService.getBotReply(messageText);
          
          if (success && data) {
            console.log('🤖 MessagesPage: Got bot reply:', data);
            
            // Parse bot response and format for AvatarMessageBubble display
            let botText = '';
            let clips = [];
            
            try {
              if (data.reply) {
                // Try to parse structured response
                const outer = JSON.parse(data.reply);
                const entries = Array.isArray(outer) && Array.isArray(outer[0]) ? outer[0] : [];
                
                if (entries.length > 0) {
                  clips = entries.map(entry => {
                    // Construct video URL same way as MeetingPage
                    let videoUrl = 'Video URL not available';
                    if (entry.title && entry.videodetails?.snippetstarttimesecs !== undefined && entry.videodetails?.snippetendtimesecs !== undefined) {
                      try {
                        videoUrl = `https://clavisds02.feeltiptop.com/360TeamCalls/downloads/` +
                          entry.title.slice(0,4) + '/' + entry.title.slice(5,7) + '/' + entry.title + '/' + entry.title + '.mp4' +
                          `#t=${entry.videodetails.snippetstarttimesecs},${entry.videodetails.snippetendtimesecs}`;
                      } catch (urlError) {
                        console.log('🤖 MessagesPage: Error constructing video URL:', urlError);
                        videoUrl = 'Error generating video URL';
                      }
                    }
                    
                    return {
                      title: entry.title || 'Untitled',
                      snippet: entry.snippet || 'No description available',
                      videodetails: entry.videodetails || {},
                      videoUrl: videoUrl,
                      originalEntry: entry
                    };
                  });
                  
                  // Format response text for AvatarMessageBubble parsing
                  let responseText = `I found ${clips.length} relevant video${clips.length > 1 ? 's' : ''} for your query:\n\n`;
                  
                  clips.forEach((clip, index) => {
                    responseText += `Title: ${clip.title}\n`;
                    responseText += `Segment Text: ${clip.snippet}\n`;
                    responseText += `Video Link: ${clip.videoUrl}\n`;
                    if (index < clips.length - 1) responseText += '\n';
                  });
                  
                  botText = responseText;
                } else {
                  // Fallback to raw reply
                  botText = data.reply;
                }
              } else {
                botText = 'I received your message but couldn\'t generate a response.';
              }
            } catch (parseError) {
              // If JSON parsing fails, use raw response
              botText = data.reply || 'I received your message but couldn\'t generate a response.';
              console.log('🤖 MessagesPage: Using raw response due to parse error:', parseError);
            }
            
            // Remove typing indicator and add bot response
            setMessages(prevMessages => {
              const withoutTyping = prevMessages.filter(msg => msg._id !== typingMessage._id);
              
              const avatarMessage = {
                _id: `avatar_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                conversationId: selected._id,
                senderId: 'avatar_system_user',
                senderName: 'Avatar',
                text: botText,
                clips: clips, // Include parsed clips for potential future use
                createdAt: new Date().toISOString(),
                timestamp: new Date().toISOString(),
                isAvatarMessage: true,
                status: 'sent'
              };
              
              const newMessages = [...withoutTyping, avatarMessage];
              setAvatarMessages(prev => {
                const newMap = new Map(prev);
                newMap.set(selected._id, newMessages);
                return newMap;
              });
              return newMessages;
            });
            
            // Update conversation's last message for sidebar
            setAllConversations(prevSections => {
              const updatedSections = prevSections.map(section => ({
                ...section,
                items: section.items.map(conv => {
                  if (conv._id === selected._id) {
                    return {
                      ...conv,
                      lastMessage: {
                        text: botText.length > 50 ? botText.substring(0, 50) + '...' : botText,
                        senderId: 'avatar_system_user',
                        senderName: 'Avatar',
                        timestamp: new Date().toISOString()
                      },
                      lastMessageAt: new Date().toISOString()
                    };
                  }
                  return conv;
                })
              })).map(section => ({
                ...section,
                items: sortConversationsWithAvatarTop(section.items)
              }));
              return updatedSections;
            });
            
          } else {
            throw new Error(error || 'Bot service returned no data');
          }
          
        } catch (processingError) {
          console.error('🤖 MessagesPage: Error processing avatar query:', processingError);
          
          // Remove typing indicator and add error message
          setMessages(prevMessages => {
            const withoutTyping = prevMessages.filter(msg => msg._id !== typingMessage._id);
            
            const errorMessage = {
              _id: `avatar_error_${Date.now()}`,
              conversationId: selected._id,
              senderId: 'avatar_system_user',
              senderName: 'Avatar',
              text: 'Sorry, I encountered an error while processing your request. Please try again.',
              createdAt: new Date().toISOString(),
              timestamp: new Date().toISOString(),
              isAvatarMessage: true,
              status: 'error'
            };
            
            const newMessages = [...withoutTyping, errorMessage];
            setAvatarMessages(prev => {
              const newMap = new Map(prev);
              newMap.set(selected._id, newMessages);
              return newMap;
            });
            return newMessages;
          });
        }
        
      } catch (error) {
        console.error('🤖 MessagesPage: Error in avatar chat handling:', error);
        setNotification({
          message: 'Failed to send message to avatar. Please try again.'
        });
        setTimeout(() => setNotification(null), 3000);
      } finally {
        setIsSending(false);
      }
      
      console.log('🤖 MessagesPage: Exiting early after avatar conversation handling');
      return; // Exit early, don't continue with normal message sending
    }

    console.log('🤖 MessagesPage: Starting normal message sending process');
    console.log('🤖 MessagesPage: This should NOT happen for avatar conversations!');
    setIsSending(true);
    setUploadProgress(0);

    try {
      let fileMeta = null;
      
      // Handle file upload with progress tracking
      if (uploadFile) {
        try {
          const res = await messageAPI.uploadMessageFile(uploadFile);
          fileMeta = res.data;
          setUploadProgress(100);
        } catch (uploadError) {
          console.error('File upload failed:', uploadError);
          setNotification({
            message: 'Failed to upload file. Please try again.'
          });
          setTimeout(() => setNotification(null), 3000);
          setIsSending(false);
          return;
        }
      }
      
      // Build an optimistic message object with loading state
      const tempId = `temp-${Date.now()}`;
      const tempMsg = {
        _id: tempId,
        tempId, // Keep track of temp ID for status updates
        conversationId: selected._id,
        senderId: user?.id,
        senderName: user?.fullName || user?.username || '',
        text: input.trim(),
        file: fileMeta,
        replyTo: replyTo ? {
          _id: replyTo._id,
          text: replyTo.text,
          file: replyTo.file
        } : undefined,
        createdAt: new Date().toISOString(),
        pending: true,
        sending: true, // Mark as currently sending
      };
      
      // Set initial status as sending
      try {
        if (messageStatus && typeof messageStatus.setMessageStatus === 'function') {
          messageStatus.setMessageStatus(tempId, MESSAGE_STATUS.SENDING);
        }
      } catch (error) {
        console.error('Error setting message status:', error);
      }
      
      // Add optimistic message to UI immediately
      setMessages(prev => [...prev, tempMsg]);
      
      // Update message cache for this conversation
      setMessagesCache(cache => {
        const convMsgs = cache[selected._id] || [];
        return {
          ...cache,
          [selected._id]: [...convMsgs, tempMsg],
        };
      });
      
      // Optimistically move conversation to top
      moveConversationToTop(
        selected._id,
        {
          text: input.trim() || (uploadFile ? undefined : ''),
          file: uploadFile ? { name: uploadFile.name } : undefined,
          createdAt: new Date().toISOString(),
          senderName: 'You'
        },
        new Date().toISOString()
      );
      
      // Prepare message data for sending (capture input before clearing)
      const messageData = {
        tempId,
        conversationId: selected._id,
        text: input.trim(),
        file: fileMeta,
        replyTo: replyTo ? replyTo._id : undefined,
        senderId: user?.id,
        senderName: user?.fullName || user?.username || '',
        createdAt: new Date().toISOString()
      };

      // Clear input fields immediately after preparing message data for better UX
      setInput('');
      setUploadFile(null);
      setReplyTo(null);
      setShowEmojiPicker(false);

      // Send message with network resilience
      try {
        await sendMessageWithRetry(messageData);
      } catch (error) {
        console.error('Failed to send message:', error);
        // Message will be queued by sendMessageWithRetry
      }
      
      // Show success notification for file uploads
      if (uploadFile) {
        setNotification({
          message: 'File sent successfully!'
        });
        setTimeout(() => setNotification(null), 2000);
      }
      
    } catch (error) {
      console.error('Error in message handling:', error);
      // Don't remove optimistic messages - let the queue system handle retries
      setNotification({
        message: 'Message queued for sending when connection improves'
      });
      setTimeout(() => setNotification(null), 3000);
    } finally {
      setIsSending(false);
      setUploadProgress(0);
    }
  };

  const handleEdit = (msg) => {
    setEditMsgId(msg._id || msg.id);
    setEditInput(msg.text);
  };

  const handleEditSave = async () => {
    chatSocket.editMessage({ messageId: editMsgId, text: editInput });
    setEditMsgId(null);
    setEditInput('');
  };

  const handleEditCancel = () => {
    setEditMsgId(null);
    setEditInput('');
  };

  const handleAvatarResponse = async (avatarResponse) => {
    try {
      console.log('🤖 MessagesPage: Handling avatar response:', avatarResponse);
      
      if (avatarResponse && selected) {
        // Add the avatar response message to the current conversation
        const avatarMessage = {
          ...avatarResponse,
          tempId: `avatar_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          conversationId: selected._id,
          timestamp: new Date().toISOString()
        };
        
        // Add avatar message to messages state
        setMessages(prevMessages => {
          const newMessages = [...prevMessages, avatarMessage];
          console.log('🤖 MessagesPage: Updated messages with avatar response');
          return newMessages;
        });
        
        // Update conversation's last message
        setAllConversations(prevSections => {
          const updatedSections = prevSections.map(section => ({
            ...section,
            items: section.items.map(conv => {
              if (conv._id === selected._id) {
                return {
                  ...conv,
                  lastMessage: {
                    text: avatarMessage.text.substring(0, 100) + '...',
                    senderId: avatarMessage.senderId,
                    senderName: 'Avatar',
                    timestamp: avatarMessage.timestamp
                  },
                  lastMessageAt: avatarMessage.timestamp
                };
              }
              return conv;
            })
          })).map(section => ({
            ...section,
            items: sortConversationsWithAvatarTop(section.items)
          }));
          return updatedSections;
        });
      }
    } catch (error) {
      console.error('🤖 MessagesPage: Error handling avatar response:', error);
    }
  };

  const handleDelete = async (msgId) => {
    chatSocket.deleteMessage({ messageId: msgId });
  };

  const handleStar = (convId) => {
    setStarred(prev => prev.includes(convId) ? prev.filter(id => id !== convId) : [...prev, convId]);
    // Optionally: persist star via API
  };

  const handlePin = (convId) => {
    // Don't allow pinning avatar conversations
    const targetConv = allConversations[0]?.items?.find(c => c._id === convId);
    if (targetConv && (targetConv.conversationType === 'ai_avatar' || 
                       targetConv.settings?.isAvatarConversation ||
                       targetConv._id?.startsWith('avatar_conversation_'))) {
      console.log('🤖 MessagesPage: Cannot pin avatar conversation - already at top');
      return;
    }
    
    setAllConversations(prev => {
      const newSections = [...prev];
      const sectionIndex = 0; // Unified structure
      
      if (sectionIndex < newSections.length) {
        const items = [...newSections[sectionIndex].items];
        const convIndex = items.findIndex(c => c._id === convId);
        
        if (convIndex !== -1) {
          const currentlyPinned = items[convIndex].isPinned;
          const newPinnedState = !currentlyPinned;
          
          items[convIndex] = {
            ...items[convIndex],
            isPinned: newPinnedState
          };
          
          // Update the pinned conversations list for persistence
          setPinnedConversations(prevPinned => {
            if (newPinnedState) {
              // Add to pinned list if not already there
              return prevPinned.includes(convId) ? prevPinned : [...prevPinned, convId];
            } else {
              // Remove from pinned list
              return prevPinned.filter(id => id !== convId);
            }
          });
          
          // Sort with proper hierarchy: Avatar → Pinned → Regular
          const sortedItems = sortConversationsWithAvatarTop(items);
          
          newSections[sectionIndex] = {
            ...newSections[sectionIndex],
            items: sortedItems
          };
        }
      }
      
      return newSections;
    });
  };

  const handleMute = (convId) => {
    setAllConversations(prev => {
      const newSections = [...prev];
      const sectionIndex = 0; // Unified structure
      
      if (sectionIndex < newSections.length) {
        const items = [...newSections[sectionIndex].items];
        const convIndex = items.findIndex(c => c._id === convId);
        
        if (convIndex !== -1) {
          items[convIndex] = {
            ...items[convIndex],
            isMuted: !items[convIndex].isMuted
          };
          
          newSections[sectionIndex] = {
            ...newSections[sectionIndex],
            items
          };
        }
      }
      
      return newSections;
    });
  };

  const saveDraftMessage = (conversationId, text) => {
    setDraftMessages(prev => {
      const updated = { ...prev };
      if (text.trim()) {
        updated[conversationId] = text;
      } else {
        delete updated[conversationId];
      }
      localStorage.setItem('draftMessages', JSON.stringify(updated));
      return updated;
    });
  };

  const handleDismissDeletedConversation = (conversationId) => {
    console.log('🗑️ Dismissing deleted conversation:', conversationId);
    
    // Remove from conversations list
    setAllConversations(prev => {
      const newSections = prev.map(section => ({
        ...section,
        items: section.items.filter(c => c._id !== conversationId)
      }));
      
      // Update ref
      allConversationsRef.current = newSections;
      return newSections;
    });
    
    // If this was the selected conversation, clear selection
    if (selected && selected._id === conversationId) {
      setSelected(null);
      selectedRef.current = null;
      setMessages([]);
    }
    
    // Remove from message cache
    setMessagesCache(prev => {
      const newCache = { ...prev };
      delete newCache[conversationId];
      
      // Update localStorage
      try {
        localStorage.setItem('messagesCache', JSON.stringify(newCache));
      } catch (error) {
        console.error('Error updating localStorage cache:', error);
      }
      
      messagesCacheRef.current = newCache;
      return newCache;
    });
    
    // Refresh unread count in header
    if (refreshUnreadCount) refreshUnreadCount();
    
    setNotification({
      message: 'Conversation dismissed'
    });
    setTimeout(() => setNotification(null), 2000);
  };

  const handleDeleteConversation = async (conv) => {
    if (!conv || !conv._id) return;
    
    try {
      await conversationAPI.deleteConversation(conv._id);
      
      // Immediate local update - don't wait for socket events
      setAllConversations(prev => {
        const newSections = prev.map(section => ({
          ...section,
          items: section.items.filter(c => c._id !== conv._id)
        }));
        
        // Update ref
        allConversationsRef.current = newSections;
        return newSections;
      });
      
      // If this was the selected conversation, clear selection
      if (selected && selected._id === conv._id) {
        setSelected(null);
        selectedRef.current = null;
        setMessages([]);
      }
      
      // Remove from message cache
      setMessagesCache(prev => {
        const newCache = { ...prev };
        delete newCache[conv._id];
        
        // Update localStorage
        try {
          localStorage.setItem('messagesCache', JSON.stringify(newCache));
        } catch (error) {
          console.error('Error updating localStorage cache:', error);
        }
        
        messagesCacheRef.current = newCache;
        return newCache;
      });
      
      // Backend will automatically emit 'conversation:deleted' event to all members
      
      // Refresh unread count in header
      if (refreshUnreadCount) refreshUnreadCount();
      
      setNotification({
        message: 'Conversation deleted successfully!'
      });
      setNotification(null);
    } catch (error) {
      console.error('Error deleting conversation:', error);
      setNotification({
        message: error.response?.data?.message || 'Failed to delete conversation'
      });
      setNotification(null);
    }
  };

  // Client-side search fallback function
  const performClientSideSearch = (searchQuery, searchFilters = {}) => {
    if (!messages || !searchQuery || !Array.isArray(messages)) return [];
    
    const query = searchQuery.toLowerCase().trim();
    if (!query) return [];
    
    return messages.filter(msg => {
      if (!msg) return false;
      
      // Basic text search - more robust
      const textMatch = msg.text && typeof msg.text === 'string' && msg.text.toLowerCase().includes(query);
      const fileNameMatch = msg.file && msg.file.name && typeof msg.file.name === 'string' && msg.file.name.toLowerCase().includes(query);
      
      if (!textMatch && !fileNameMatch) return false;
      
      // Filter by type
      if (searchFilters.type && searchFilters.type !== 'all') {
        if (searchFilters.type === 'text' && msg.file) return false;
        if (searchFilters.type === 'file' && !msg.file) return false;
        if (searchFilters.type === 'image' && (!msg.file || !msg.file.type?.startsWith('image/'))) return false;
      }
      
      // Filter by sender - more robust
      if (searchFilters.sender && searchFilters.sender !== 'all') {
        let senderId = null;
        
        // Handle different sender ID formats
        if (msg.senderId) {
          senderId = msg.senderId;
        } else if (typeof msg.sender === 'string') {
          senderId = msg.sender;
        } else if (msg.sender && typeof msg.sender === 'object' && msg.sender._id) {
          senderId = msg.sender._id;
        }
        
        if (searchFilters.sender === 'me') {
          if (!user?.id || senderId !== user.id) return false;
        } else if (senderId !== searchFilters.sender) {
          return false;
        }
      }
      
      // Filter by date range - safer date handling
      if (searchFilters.dateRange && searchFilters.dateRange !== 'all') {
        const timestamp = msg.createdAt || msg.timestamp;
        if (!timestamp) return true; // Don't filter if no timestamp
        
        const msgDate = new Date(timestamp);
        if (isNaN(msgDate.getTime())) return true; // Don't filter if invalid date
        
        const now = new Date();
        
        switch (searchFilters.dateRange) {
          case 'today':
            if (msgDate.toDateString() !== now.toDateString()) return false;
            break;
          case 'week':
            const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            if (msgDate < weekAgo) return false;
            break;
          case 'month':
            const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            if (msgDate < monthAgo) return false;
            break;
        }
      }
      
      return true;
    }).slice(0, 50); // Limit results
  };

  // Message action handlers
  const handlePinMessage = (messageId) => {
    setPinnedMessages(prev => {
      if (prev.includes(messageId)) {
        return prev.filter(id => id !== messageId);
      } else {
        return [...prev, messageId];
      }
    });
  };

  const handleStarMessage = (messageId) => {
    setStarredMessages(prev => {
      if (prev.includes(messageId)) {
        return prev.filter(id => id !== messageId);
      } else {
        return [...prev, messageId];
      }
    });
  };

  // Load more messages function for infinite scroll
  const handleLoadMoreMessages = async () => {
    if (!selected?._id || loadingMore || !hasMoreMessages) return;
    
    // Don't load more messages for avatar conversations - they're client-side only
    if (isAvatarConversation && isAvatarConversation(selected)) {
      console.log('🤖 MessagesPage: Skipping handleLoadMoreMessages for avatar conversation');
      return;
    }
    
    setLoadingMore(true);
    
    try {
      const response = await messageAPI.getMessages(selected._id, {
        limit: 50,
        skip: messageOffset
      });
      
      const olderMessages = (response.data.messages || []).reverse(); // Reverse since API now returns newest first
      
      if (olderMessages.length > 0) {
        // Use mergeMessages to properly deduplicate and merge older messages
        setMessages(prev => {
          const mergedMessages = mergeMessages(olderMessages, prev);
          return mergedMessages;
        });
        
        // Only increment offset by the number of unique new messages
        const uniqueOlderMessages = olderMessages.filter(olderMsg => 
          !messages.some(existingMsg => existingMsg._id === olderMsg._id)
        );
        setMessageOffset(prev => prev + uniqueOlderMessages.length);
        setHasMoreMessages(olderMessages.length === 50);
        
        // Update reactions state for newly loaded older messages
        const olderReactions = {};
        uniqueOlderMessages.forEach(msg => {
          if (msg.reactions && msg.reactions.length > 0) {
            olderReactions[msg._id] = msg.reactions;
          }
        });
        setReactions(prev => ({ ...olderReactions, ...prev })); // Add older reactions first
        
        // Update cache with proper merging
        setMessagesCache(prev => ({
          ...prev,
          [selected._id]: mergeMessages(olderMessages, prev[selected._id] || [])
        }));
      } else {
        setHasMoreMessages(false);
      }
    } catch (error) {
      console.error('Error loading more messages:', error);
      setHasMoreMessages(false);
    } finally {
      setLoadingMore(false);
    }
  };

  const handleConversationCreated = async (newConversation) => {
    // Immediate local update - don't wait for socket events
    setAllConversations(prev => {
      const newSections = [...prev];
      // With unified structure, we always use the first (and only) section
      const sectionIndex = 0;
      
      if (sectionIndex < newSections.length) {
        // Remove all existing duplicates from the section
        const idMap = new Map();
        const nameMap = new Map();
        
        const cleanedItems = newSections[sectionIndex].items.filter((item) => {
          // Track ID duplicates
          if (idMap.has(item._id)) {
            return false;
          }
          idMap.set(item._id, true);
          
          // Track name duplicates for communities
          if (item.type === 'community' && item.name) {
            if (nameMap.has(item.name)) {
              return false;
            }
            nameMap.set(item.name, true);
          }
          
          return true;
        });
        
        // Check if new conversation would be a duplicate
        const wouldBeDuplicateId = idMap.has(newConversation._id);
        const wouldBeDuplicateName = newConversation.type === 'community' && newConversation.name && nameMap.has(newConversation.name);
        
        if (!wouldBeDuplicateId && !wouldBeDuplicateName) {
          const newConversationWithTimestamp = {
            ...newConversation,
            _lastUpdated: Date.now(),
            _forceRender: Math.random()
          };
          
          // Add to the top of the unified list (keeping avatar conversation at top)
          const updatedItems = sortConversationsWithAvatarTop([newConversationWithTimestamp, ...cleanedItems]);
          
          newSections[sectionIndex] = {
            ...newSections[sectionIndex],
            items: updatedItems,
            _lastUpdated: Date.now()
          };
        } else {
          newSections[sectionIndex] = {
            ...newSections[sectionIndex],
            items: cleanedItems,
            _lastUpdated: Date.now()
          };
        }
      }
      
      return newSections;
    });
    
    // Select the new conversation
    handleSelect(newConversation);
    
    setNotification({
      message: 'Conversation created successfully!'
    });
    setNotification(null);
  };

  const handleConversationUpdated = async () => {
    // Refresh conversations list
    fetchConversations();
    
    // If there's a selected conversation, refetch its details to update the UI
    if (selected && selected._id) {
      try {
        const response = await conversationAPI.getConversation(selected._id);
        if (response.data && response.data.conversation) {
          setSelected(response.data.conversation);
        }
      } catch (error) {
        console.error('Failed to refetch conversation details:', error);
      }
    }
    
    setNotification({
      message: 'Conversation updated successfully!'
    });
    setTimeout(() => setNotification(null), 3000);
  };

  const handleConversationDeleted = (conversationId) => {
    // Immediate local update - don't wait for socket events
    setAllConversations(prev => {
      const newSections = prev.map(section => ({
        ...section,
        items: section.items.filter(c => c._id !== conversationId)
      }));
      
      // Update ref
      allConversationsRef.current = newSections;
      return newSections;
    });
    
    // If this was the selected conversation, clear selection
    if (selected && selected._id === conversationId) {
      setSelected(null);
      selectedRef.current = null;
      setMessages([]);
    }
    
    // Remove from message cache
    setMessagesCache(prev => {
      const newCache = { ...prev };
      delete newCache[conversationId];
      
      // Update localStorage
      try {
        localStorage.setItem('messagesCache', JSON.stringify(newCache));
      } catch (error) {
        console.error('Error updating localStorage cache:', error);
      }
      
      messagesCacheRef.current = newCache;
      return newCache;
    });
    
    // Backend will automatically emit 'conversation:deleted' event to all members
    
    // Refresh unread count in header
    if (refreshUnreadCount) refreshUnreadCount();
    
    setNotification({
      message: 'Conversation deleted successfully!'
    });
    setNotification(null);
  };

  const handleUserSelect = async (selectedUser) => {
    try {
      const response = await conversationAPI.createConversation({
        type: 'dm',
        memberIds: [selectedUser._id]
      });
      
      const newConversation = response.data.conversation;
      
      // Immediate local update - don't wait for socket events
      setAllConversations(prev => {
        const newSections = [...prev];
        // With unified structure, we always use the first (and only) section
        const sectionIndex = 0;
        
        if (sectionIndex < newSections.length) {
          // Check if conversation already exists to prevent duplicates
          const existingIndex = newSections[sectionIndex].items.findIndex(
            item => item._id === newConversation._id
          );
          
          if (existingIndex === -1) {
            // Add to top and re-sort by most recent activity (keeping avatar at top)
            const updatedItems = sortConversationsWithAvatarTop([newConversation, ...newSections[sectionIndex].items]);
            
            newSections[sectionIndex] = {
              ...newSections[sectionIndex],
              items: updatedItems
            };
          }
        }
        
        return newSections;
      });
      
      // Update refs for real-time access
      setAllConversations(prev => {
        allConversationsRef.current = prev;
        return prev;
      });
      
      // Select the new conversation
      handleSelect(newConversation);
      
      // System notifications will be handled by the backend automatically
      // No need to manually send messages from the client
      
      // Backend will automatically emit 'conversation:created' event to all members
      // and generate system messages when the API endpoint is called
      
      setNotification({
        message: response.data.message || 'Conversation created successfully!'
      });
      setNotification(null);
    } catch (error) {
      console.error('Error creating conversation:', error);
      setNotification({
        message: error.response?.data?.message || 'Failed to create conversation'
      });
      setNotification(null);
    }
  };

  const handleFileChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      setUploadFile(file);
    }
  };

  const handleRemoveFile = () => {
    setUploadFile(null);
  };

  const handleEmojiClick = async (emoji, msgId) => {
    try {
      setReactionInProgress(true);
      
      // Use the REST API instead of socket for proper toggle logic
      const response = await messageAPI.reactMessage(msgId, emoji);
      
      // Update the local message state with the updated reactions
      const updatedMessage = response.data.message;
      setMessages(prev => prev.map(m => 
        m._id === msgId ? { ...m, reactions: updatedMessage.reactions } : m
      ));
      
      // Update the reactions state as well
      setReactions(prev => ({
        ...prev,
        [msgId]: updatedMessage.reactions
      }));
      
      // Close emoji picker after a small delay to prevent auto-scroll
      setTimeout(() => {
        setShowEmojiPicker(false);
        setReactionInProgress(false);
      }, 150);
    } catch (error) {
      console.error('Error reacting to message:', error);
      setShowEmojiPicker(false);
      setReactionInProgress(false);
    }
  };

  const handleReply = (msg) => {
    setReplyTo(msg);
  };

  const handleTyping = (isTyping) => {
    if (selected && chatSocket.sendTyping) {
      chatSocket.sendTyping({ conversationId: selected._id, typing: isTyping });
    }
  };

  // Search functionality
  const handleSearch = async (query, filters) => {
    if (!selected || !query.trim()) {
      console.warn('Search cancelled: no conversation selected or empty query');
      return;
    }
    
    if (!selected._id) {
      console.error('Search cancelled: conversation ID is missing');
      setNotification({ message: 'Unable to search: conversation ID missing' });
      setTimeout(() => setNotification(null), 3000);
      return;
    }
    
    setIsSearching(true);
    setSearchFilters(filters);
    
    try {
      // Process and validate filters before sending to API
      const searchParams = {
        query: query.trim(),
        limit: 50
      };
      
      // Only add valid filter parameters
      if (filters.type && filters.type !== 'all') {
        searchParams.type = filters.type;
      }
      
      if (filters.dateRange && filters.dateRange !== 'all') {
        searchParams.dateRange = filters.dateRange;
      }
      
      // Handle sender filter carefully
      if (filters.sender && filters.sender !== 'all') {
        if (filters.sender === 'me') {
          if (user?.id) {
            searchParams.sender = user.id;
          } else {
            console.warn('Cannot filter by "me": user ID not available');
          }
        } else {
          searchParams.sender = filters.sender;
        }
      }
      
      // For now, skip API and go directly to client-side search due to server issues
      // When API is fixed, replace this with:
      // const response = await messageAPI.searchMessages(selected._id, searchParams);
      throw new Error('Using client-side search');
      
      const results = response.data.messages || [];
      setSearchResults(results);
      setTotalSearchResults(response.data.total || results.length);
      setCurrentSearchResult(0);
    } catch (error) {
      console.error('Search error:', error);
      
      // Always fall back to client-side search for now since API has issues
      console.log('API search failed, falling back to client-side search');
      const clientResults = performClientSideSearch(query.trim(), filters);
      setSearchResults(clientResults);
      setTotalSearchResults(clientResults.length);
      setCurrentSearchResult(0);
      
      // Show notification about results
      if (clientResults.length > 0) {
        setNotification({
          message: `Found ${clientResults.length} result${clientResults.length !== 1 ? 's' : ''} for "${query.trim()}"`
        });
      } else {
        setNotification({
          message: `No results found for "${query.trim()}"`
        });
      }
      setTimeout(() => setNotification(null), 3000);
    } finally {
      setIsSearching(false);
    }
  };

  const handleClearSearch = () => {
    setSearchResults([]);
    setTotalSearchResults(0);
    setCurrentSearchResult(0);
    setSearchFilters(null);
  };

  const handleNavigateSearchResult = (direction, index) => {
    if (direction === 'goto' && typeof index === 'number') {
      setCurrentSearchResult(index);
      // Scroll to message in ChatWindow
      const messageId = searchResults[index]?._id;
      if (messageId) {
        const messageElement = document.getElementById(`message-${messageId}`);
        if (messageElement) {
          messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    } else if (direction === 'next' && currentSearchResult < totalSearchResults - 1) {
      const newIndex = currentSearchResult + 1;
      setCurrentSearchResult(newIndex);
      handleNavigateSearchResult('goto', newIndex);
    } else if (direction === 'previous' && currentSearchResult > 0) {
      const newIndex = currentSearchResult - 1;
      setCurrentSearchResult(newIndex);
      handleNavigateSearchResult('goto', newIndex);
    }
  };

  // Debug helper for development
  useEffect(() => {
    if (import.meta.env.DEV) {
      window.debugMessagesPage = {
        conversations: allConversations,
        cache: messagesCache,
        selected,
        user,
        clearCache: () => {
          localStorage.removeItem('messagesCache');
          localStorage.removeItem('chat_notifications');
          localStorage.removeItem('unread_count');
          localStorage.removeItem('chatSearchHistory');
          sessionStorage.removeItem('app_errors');
          window.location.reload();
        }
      };
    }
  });

  return (
    <div className="flex h-[100dvh] sm:h-[85vh] bg-gradient-to-br from-gray-50 via-blue-50 to-purple-50 sm:rounded-2xl shadow-2xl overflow-hidden border-0 sm:border border-gray-100">
      {/* Sidebar - Full width on mobile when open */}
      {(!isMobile || sidebarOpen) && (
        <div className={`${isMobile ? 'w-full' : 'w-80 lg:w-96'} bg-white/80 backdrop-blur-sm border-r border-gray-200 flex flex-col`}>
          {/* Header - More compact */}
          <div className="p-2 md:p-4 border-b border-gray-100 bg-gradient-to-r from-blue-50 to-purple-50">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-1.5 md:space-x-3">
                <div className="p-1 md:p-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-md">
                  <MessageCircle className="h-3.5 w-3.5 md:h-5 md:w-5" />
                </div>
                <div>
                  <h1 className="text-sm md:text-lg font-bold text-gray-900">Messages</h1>
                  <p className="text-xs text-gray-600 hidden sm:block">Connect with your team</p>
                </div>
              </div>
              <button 
                onClick={() => setShowCreateModal(true)} 
                className="p-1 md:p-2 rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 text-white hover:from-blue-600 hover:to-purple-600 transition-all duration-200 shadow-md hover:shadow-lg transform hover:scale-105"
                title="New Conversation"
              >
                <Plus className="h-3.5 w-3.5 md:h-4 md:w-4" />
              </button>
            </div>
          </div>

          {/* Search - More compact */}
          <div className="p-1.5 md:p-3 border-b border-gray-100">
            <div className="relative">
              <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-3 w-3 md:h-3.5 md:w-3.5 text-gray-400" />
              <input
                type="text"
                placeholder="Search conversations..."
                value={search}
                onChange={e => setSearch(e.target.value)}
                className="w-full pl-7 md:pl-9 pr-2 md:pr-3 py-1.5 md:py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 bg-gray-50 focus:bg-white shadow-sm text-xs md:text-sm"
              />
            </div>
          </div>

          {/* Conversations List - Unified without sections */}
          <div className="flex-1 overflow-y-auto py-1">
            {filteredConversations.length > 0 && filteredConversations[0].items.map((conv, index) => {
              return (
                <SidebarConversation
                  key={`${conv._id}-${conv.name}-${index}-${conv._lastUpdated || 0}`}
                  conv={conv}
                  isActive={selected && selected._id === conv._id}
                  onSelect={() => handleSelect(conv)}
                  onStar={() => handleStar(conv._id)}
                  onPin={() => handlePin(conv._id)}
                  onMute={() => handleMute(conv._id)}
                  onDelete={() => handleDeleteConversation(conv)}
                  onDismissDeleted={() => handleDismissDeletedConversation(conv._id)}
                  starred={starred.includes(conv._id)}
                  getInitials={getInitials}
                  currentUserId={user?._id || user?.id}
                  typing={typing[conv._id] || {}}
                  draftMessage={draftMessages[conv._id]}
                  canDelete={
                    !conv.isDeleted && (
                      conv.type === 'dm' || 
                      (conv.type === 'group' && conv.admins?.includes(user?.id)) ||
                      (conv.type === 'community' && conv.admins?.includes(user?.id))
                    )
                  }
                />
              );
            })}
          </div>
        </div>
      )}

      {/* Chat Window - Full width on mobile when sidebar is closed */}
      {(!isMobile || (!sidebarOpen && selected)) && (
        <div className="flex-1 flex flex-col bg-white/60 backdrop-blur-sm min-w-0 overflow-hidden">
          {/* Mobile back button */}
          {isMobile && (
            <div className="flex items-center justify-between px-3 py-2 border-b border-gray-100 bg-gradient-to-r from-blue-50 to-purple-50">
              <button
                className="p-2 rounded-full bg-blue-100 text-blue-600 shadow-md hover:bg-blue-200 transition-colors"
                onClick={() => setSidebarOpen(true)}
              >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                  <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                </svg>
              </button>
              <h2 className="text-base font-bold text-gray-900">Messages</h2>
              <div className="w-9"></div> {/* Spacer for centering */}
            </div>
          )}

          {/* Chat header */}
          {selected ? (
            <div className="border-b border-gray-100 px-3 md:px-6 py-2 md:py-4 bg-gradient-to-r from-gray-50 to-blue-50">
              <div className="flex items-center justify-between">
                <div 
                  className={`flex items-center space-x-2 md:space-x-4 p-1 md:p-3 rounded-xl transition-all duration-200 ${
                    isAvatarConversation && isAvatarConversation(selected) 
                      ? '' 
                      : 'cursor-pointer hover:bg-white/50'
                  }`}
                  onClick={() => !(isAvatarConversation && isAvatarConversation(selected)) && setShowDetailsModal(true)}
                >
                  <div className="relative">
                    {selected.avatar ? (
                      <img src={selected.avatar} alt={selected.name || 'Conversation'} className="h-8 w-8 md:h-12 md:w-12 rounded-full object-cover shadow-lg" />
                    ) : (
                      <div className="h-8 w-8 md:h-12 md:w-12 rounded-full bg-gradient-to-r from-blue-500 to-purple-500 flex items-center justify-center text-white font-bold text-sm md:text-lg shadow-lg">
                        {getInitials(getConversationDisplayName(selected, user?._id || user?.id))}
                      </div>
                    )}
                    {selected.status && (
                      <span className={`absolute -bottom-1 -right-1 h-3 w-3 md:h-4 md:w-4 rounded-full border-2 md:border-3 border-white ${selected.status === 'online' ? 'bg-green-500' : 'bg-gray-400'} shadow-md`}></span>
                    )}
                  </div>
                  <div className="flex flex-col min-w-0 flex-1">
                    <h2 className="text-sm md:text-lg font-bold text-gray-900 truncate">{getConversationDisplayName(selected, user?._id || user?.id)}</h2>
                    {selected && (selected.type === 'group' || selected.type === 'community') && (
                      <p className="text-xs text-gray-600">
                        {selected.members?.length || 0} members
                      </p>
                    )}
                  </div>
                </div>
                <div className="flex items-center space-x-1 md:space-x-2">
                  <button
                    onClick={() => setShowSearch(!showSearch)}
                    className={`p-2 rounded-xl transition-all duration-200 ${
                      showSearch 
                        ? 'bg-blue-100 text-blue-700 hover:bg-blue-200' 
                        : 'hover:bg-white/50 text-gray-500 hover:text-gray-700'
                    }`}
                    title="Search Messages"
                  >
                    <Search className="h-4 w-4 md:h-5 md:w-5" />
                  </button>
                  {selected && !(isAvatarConversation && isAvatarConversation(selected)) && (
                    <button 
                      onClick={() => setShowSettingsModal(true)} 
                      className="p-2 rounded-xl hover:bg-white/50 transition-all duration-200 text-gray-500 hover:text-gray-700" 
                      title="Conversation Settings"
                    >
                      <Settings className="h-4 w-4 md:h-5 md:w-5" />
                    </button>
                  )}
                </div>
              </div>
            </div>
          ) : (
            <div className="border-b border-gray-100 px-3 md:px-6 py-4 md:py-8 bg-gradient-to-r from-gray-50 to-blue-50">
              <div className="text-center">
                <div className="p-2 md:p-4 rounded-full bg-gradient-to-r from-blue-500 to-purple-500 w-10 h-10 md:w-16 md:h-16 mx-auto mb-2 md:mb-4 flex items-center justify-center">
                  <MessageCircle className="h-4 w-4 md:h-8 md:w-8 text-white" />
                </div>
                <h2 className="text-base md:text-xl font-bold text-gray-900 mb-1 md:mb-2">Welcome to Messages</h2>
                <p className="text-xs md:text-base text-gray-600">Select a conversation to start chatting</p>
              </div>
            </div>
          )}

          {/* Search Component */}
          {showSearch && selected && (
            <ChatSearch
              onSearch={handleSearch}
              onClose={() => {
                setShowSearch(false);
                handleClearSearch();
              }}
              searchResults={searchResults}
              isSearching={isSearching}
              currentResult={currentSearchResult}
              totalResults={totalSearchResults}
              onNavigateResult={handleNavigateSearchResult}
              onClearSearch={handleClearSearch}
            />
          )}

          {/* Reply context */}
          {replyTo && (
            <div className="px-4 md:px-6 py-2 bg-blue-50 border-b border-blue-100">
              <div className="flex items-center justify-between">
                <div className="flex-1 min-w-0">
                  <p className="text-xs md:text-sm text-blue-600 font-medium">Replying to {replyTo.senderName || 'message'}</p>
                  <p className="text-xs md:text-sm text-blue-500 truncate">{replyTo.text || 'File'}</p>
                </div>
                <button 
                  onClick={() => setReplyTo(null)} 
                  className="ml-2 p-1 rounded-full text-blue-400 hover:text-blue-600 hover:bg-blue-100 transition-colors"
                >
                  <X className="h-4 w-4" />
                </button>
              </div>
            </div>
          )}

          {/* Messages */}
          {selected && (
            <ChatWindow
              loading={messagesLoading}
              messages={messages.filter(msg => 
                msg.conversationId === selected._id || 
                msg.conversation === selected._id
              )}
              currentUserId={user?.id}
              conversationType={selected.conversationType || selected.type}
              onEdit={handleEdit}
              onDelete={handleDelete}
              onReply={handleReply}
              onEmoji={handleEmojiClick}
              reactions={reactions}
              showEmojiPicker={showEmojiPicker}
              setShowEmojiPicker={setShowEmojiPicker}
              emojiList={emojiList}
              editMsgId={editMsgId}
              editInput={editInput}
              setEditInput={setEditInput}
              handleEditSave={handleEditSave}
              handleEditCancel={handleEditCancel}
              typing={selected && typing[selected._id] ? typing[selected._id] : {}}
              messageStatus={chatSocket.messageStatus}
              onlineUsers={Array.from(chatSocket.onlineUsers.values())}
              unreadStartIndex={unreadStartIndex}
              shouldAutoScroll={!editMsgId && !replyTo && !showSearch && !showEmojiPicker && !reactionInProgress && showEmojiPicker !== 'input'}
              searchResults={searchResults}
              currentSearchResult={currentSearchResult}
              searchFilters={searchFilters}
              onPin={handlePinMessage}
              onStar={handleStarMessage}
              pinnedMessages={pinnedMessages}
              starredMessages={starredMessages}
              onLoadMore={handleLoadMoreMessages}
              hasMoreMessages={hasMoreMessages}
              loadingMore={loadingMore}
              isConversationSwitch={isConversationSwitch}
            />
          )}

          {/* Input */}
          {selected && (
            <ChatInput
              input={input}
              setInput={setInput}
              onSend={handleSend}
              onFileChange={handleFileChange}
              uploadFile={uploadFile}
              onRemoveFile={handleRemoveFile}
              onShowEmojiPicker={() => setShowEmojiPicker('input')}
              onTyping={handleTyping}
              members={selected?.members || []}
              isSending={isSending}
              uploadProgress={uploadProgress}
              conversation={selected}
              onAvatarQuery={handleAvatarResponse}
              isAvatarInitialized={isInitialized}
            />
          )}

          {/* Notification */}
          {notification && (
            <div className="fixed top-4 md:top-6 right-4 md:right-6 z-50 bg-gradient-to-r from-blue-500 to-purple-500 text-white px-4 md:px-6 py-2 md:py-3 rounded-xl shadow-2xl animate-in slide-in-from-right-4 duration-300 max-w-xs md:max-w-md">
              <div className="flex items-center space-x-2 md:space-x-3">
                <div className="p-1 rounded-full bg-white/20">
                  <Check className="h-3 w-3 md:h-4 md:w-4" />
                </div>
                <span className="font-medium text-sm md:text-base">{notification.message}</span>
                <button 
                  onClick={() => setNotification(null)} 
                  className="ml-2 md:ml-4 text-white/80 hover:text-white transition-colors"
                >
                  <X className="h-3 w-3 md:h-4 md:w-4" />
                </button>
              </div>
            </div>
          )}
        </div>
      )}
      
      {/* User Selection Modal */}
      <UserSelectionModal
        isOpen={showUserModal}
        onClose={() => setShowUserModal(false)}
        onSelectUser={handleUserSelect}
        currentUserId={user?.id}
      />

      {/* Create Conversation Modal */}
      <CreateConversationModal
        isOpen={showCreateModal}
        onClose={() => setShowCreateModal(false)}
        onConversationCreated={handleConversationCreated}
        currentUserId={user?.id}
      />

      {/* Conversation Settings Modal */}
      <ConversationSettingsModal
        isOpen={showSettingsModal}
        onClose={() => setShowSettingsModal(false)}
        conversation={selected}
        onConversationUpdated={handleConversationUpdated}
        onConversationDeleted={handleConversationDeleted}
        currentUserId={user?.id}
      />

      {/* Conversation Details Modal */}
      <ConversationDetailsModal
        isOpen={showDetailsModal}
        onClose={() => setShowDetailsModal(false)}
        conversation={selected}
        currentUserId={user?.id}
      />

      {/* Network Status and Message Queue Indicator */}
      <NetworkStatus />
    </div>
  );
} 